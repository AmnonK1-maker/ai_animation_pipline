{% extends "base.html" %}
{% block title %}AI Workflow Dashboard{% endblock %}
{% block content %}
<style>
    /* Resizable Split Layout */
    .split-container { 
        display: flex; 
        height: 100vh; 
        margin: -20px -40px; 
        box-sizing: border-box; 
    }
    
    /* Left Panel - Dashboard Tools */
    .dashboard-panel { 
        width: 40%;
        min-width: 350px;
        background: #fff; 
        padding: 20px 20px 20px 55px;
        overflow-y: auto; 
        max-height: 100vh;
        position: relative;
        border-right: 2px solid #e0e0e0;
    }
    
    /* Resizable Divider */
    .divider {
        width: 4px;
        background: #e9ecef;
        cursor: col-resize;
        position: relative;
        user-select: none;
    }
    
    .divider:hover {
        background: #007bff;
    }
    
    .divider::after {
        content: '';
        position: absolute;
        top: 50%;
        left: -2px;
        width: 8px;
        height: 30px;
        background: #007bff;
        border-radius: 4px;
        transform: translateY(-50%);
        opacity: 0;
        transition: opacity 0.2s;
    }
    
    .divider:hover::after {
        opacity: 1;
    }
    
    /* Right Panel - Job Queue */
    .queue-panel { 
        flex: 1; 
        background: #fff; 
        padding: 20px;
        overflow-y: auto; 
        max-height: 100vh;
        min-width: 300px;
    }
    
    .main-header { text-align: left; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
    .main-header h1 { font-size: 22px; margin: 0 0 5px 0; }
    .main-header p { font-size: 14px; color: #666; margin: 0; }
    
    .dashboard-section { border: 1px solid #ddd; border-radius: 8px; margin-bottom: 15px; overflow: hidden; }
    .dashboard-section summary { font-size: 16px; font-weight: 600; padding: 12px 15px; cursor: pointer; background-color: #f8f9fa; color: #333; list-style: none; display: flex; align-items: center; }
    .dashboard-section summary::-webkit-details-marker { display: none; }
    .dashboard-section summary::before { content: '▶'; font-size: 12px; transition: transform 0.2s; flex-shrink: 0; margin-left: 5px; margin-right: 12px; color: #666; }
    .dashboard-section[open] summary { border-bottom: 1px solid #ddd; }
    .dashboard-section[open] summary::before { transform: rotate(90deg); }
    .tool-content { padding: 20px; }
    
    /* Standardized Button Styles */
    .standard-btn, button, input[type="submit"], .action-btn { 
        min-height: 40px !important; 
        padding: 8px 16px !important; 
        font-size: 14px !important; 
        font-weight: 600 !important; 
        border-radius: 6px !important; 
        border: none !important; 
        cursor: pointer !important; 
        display: inline-flex !important; 
        align-items: center !important; 
        justify-content: center !important; 
        box-sizing: border-box !important; 
        text-decoration: none !important; 
    }
    
    /* Horizontal Background Options */
    .background-options-horizontal { 
        display: flex; 
        gap: 15px; 
        align-items: center; 
        flex-wrap: wrap; 
    }
    
    .background-option { 
        display: flex; 
        align-items: center; 
        gap: 8px; 
        white-space: nowrap; 
    }
    
    /* Copy Button for Text Fields */
    .text-field-container { 
        position: relative; 
    }
    
    .text-field-container textarea,
    .text-field-container input[type="text"] { 
        resize: both; 
        min-height: 40px;
        max-width: 100%;
        min-width: 200px;
    }
    
    /* Job prompt boxes should be resizable */
    .job-prompt-box {
        resize: both;
        min-height: 20px;
        max-height: none;
        vertical-align: top;
        align-self: flex-start;
    }
    
    /* Enhanced job details layout */
    .job-details {
        display: flex;
        flex-direction: column;
        gap: 15px;
    }
    
    .enhanced-job-actions {
        order: 1;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 10px;
    }
    
    .enhanced-job-content {
        order: 2;
        display: flex;
        gap: 15px;
        align-items: flex-start;
    }
    
    .enhanced-job-media {
        flex-shrink: 0;
        max-width: 500px;
        width: 100%;
    }
    
    /* Allow analysis jobs to use full width */
    .enhanced-job-item[data-job-type="style_analysis"] .enhanced-job-media,
    .enhanced-job-item[data-job-type="palette_analysis"] .enhanced-job-media,
    .enhanced-job-item[data-job-type="animation_prompting"] .enhanced-job-media {
        max-width: none;
    }
    
    /* Hide summary elements when job details are expanded */
    .enhanced-job-item[data-expanded="true"] .enhanced-job-summary .enhanced-job-thumbnail {
        display: none;
    }
    
    .enhanced-job-item[data-expanded="true"] .enhanced-job-summary .job-prompt-box {
        display: none;
    }
    
    .enhanced-job-text {
        flex: 1;
        min-width: 200px;
    }
    
    .enhanced-job-text .job-prompt-box {
        width: 100%;
        min-height: 200px;
        max-height: 400px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1.4;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        resize: both;
        vertical-align: top;
    }
    
    .enhanced-job-text .job-prompt-box:focus {
        border-color: #007bff;
        outline: none;
    }
    
    /* Image popup modal */
    .image-modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        animation: fadeIn 0.2s ease-in;
    }
    
    .image-modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 95%;
        max-height: 95%;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .image-modal-content img {
        width: 100%;
        height: auto;
        border-radius: 8px;
        display: block;
    }
    
    .image-modal-close {
        position: absolute;
        top: 20px;
        right: 30px;
        color: white;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
    }
    
    .image-modal-close:hover {
        background: rgba(0, 0, 0, 0.8);
    }
    
    .image-modal-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        font-size: 40px;
        padding: 16px 20px;
        cursor: pointer;
        border-radius: 4px;
        transition: background 0.3s;
        z-index: 10001;
    }
    
    .image-modal-nav:hover {
        background: rgba(0, 0, 0, 0.8);
    }
    
    .image-modal-prev {
        left: 20px;
    }
    
    .image-modal-next {
        right: 20px;
    }
    
    .image-modal-content.has-transparency {
        background: 
            linear-gradient(45deg, #808080 25%, transparent 25%),
            linear-gradient(-45deg, #808080 25%, transparent 25%),
            linear-gradient(45deg, transparent 75%, #808080 75%),
            linear-gradient(-45deg, transparent 75%, #808080 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        background-color: #c0c0c0;
        padding: 20px;
    }
    
    /* Clickable images */
    .clickable-image {
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .clickable-image:hover {
        transform: scale(1.02);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    /* Properly sized thumbnails in grouped jobs */
    .stacked-thumbnails .stacked-thumbnail {
        width: 80px;
        height: 80px;
    }
    
    .image-grid .image-item img {
        width: 100px;
        height: 100px;
        object-fit: cover;
        border-radius: 8px;
    }
    
    .copy-btn { 
        position: absolute; 
        right: 8px; 
        top: 8px; 
        background: none !important; 
        color: #6c757d !important; 
        border: none; 
        padding: 4px; 
        font-size: 20px; 
        border-radius: 3px; 
        cursor: pointer; 
        z-index: 10;
        transition: all 0.2s;
    }
    
    .copy-btn:hover {
        color: #495057 !important;
        background: rgba(108, 117, 125, 0.1) !important;
    }
    
    /* Enhanced Job Queue Styles */
    .job-queue-header { 
        position: sticky; 
        top: 0; 
        background: #fff; 
        z-index: 100; 
        border-bottom: 1px solid #eee; 
        padding-bottom: 15px; 
        margin-bottom: 15px; 
    }
    
    /* Header alignment with proper spacing */
    .main-header {
        margin-top: 10px;
        margin-bottom: 25px;
        margin-left: 0px;
    }
    
    .main-header h1, .job-queue-header h2 {
        margin: 15px 0 10px 0;
        line-height: 1.2;
        font-size: 24px;
        font-weight: 600;
    }
    
    .main-header p {
        margin: 0 0 20px 0;
        color: #666;
        font-size: 14px;
    }
    
    /* Always visible queue buttons - smaller size */
    .queue-actions { 
        display: flex; 
        flex-wrap: wrap; 
        gap: 6px; 
        margin-bottom: 15px; 
    }
    
    .queue-actions button { 
        min-height: 32px !important; 
        font-size: 12px !important; 
        padding: 6px 12px !important; 
        font-weight: 600 !important;
        border-radius: 4px !important;
        border: none !important;
        text-shadow: none !important;
        box-shadow: none !important;
        transition: all 0.2s !important;
    }
    
    .queue-actions button:disabled { 
        background-color: #495057 !important; 
        color: #ffffff !important;
        opacity: 0.7 !important; 
        cursor: not-allowed !important;
        text-shadow: 0 1px 2px rgba(0,0,0,0.4) !important;
        border: 1px solid #343a40 !important;
    }
    
    .queue-actions button:enabled:hover {
        transform: none !important;
        box-shadow: none !important;
    }
    
    /* Enhanced Job Item Styles */
    .enhanced-job-item { 
        border: 1px solid #e9ecef; 
        border-radius: 8px; 
        margin-bottom: 12px; 
        overflow: hidden; 
        background: #fff; 
        position: relative;
    }
    
    .enhanced-job-summary { 
        display: flex;
        align-items: center; 
        gap: 15px; 
        padding: 15px; 
        cursor: pointer; 
        background-color: #f8f9fa; 
        list-style: none;
        min-height: 80px; /* Match thumbnail height */
    }
    
    .job-selection-checkbox {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
    }
    
    .job-number-badge {
        font-weight: 600;
        font-size: 11px;
        color: #666;
        flex-shrink: 0;
        min-width: 40px;
        padding: 4px 6px;
        background: #f8f9fa;
        border-radius: 4px;
        text-align: center;
        margin-right: 8px;
    }
    
    /* Enhanced button styles for better readability */
    .standard-btn {
        background: #007bff !important; 
        color: white !important; 
        border: none !important; 
        padding: 10px 20px !important; 
        border-radius: 5px !important; 
        cursor: pointer !important; 
        font-size: 14px !important;
        font-weight: 500 !important;
        margin: 5px 5px 5px 0 !important;
        transition: all 0.2s !important;
        box-shadow: 0 2px 4px rgba(0,123,255,0.2) !important;
        text-shadow: none !important;
    }
    
    .standard-btn:hover {
        background: #0056b3 !important;
        box-shadow: 0 4px 8px rgba(0,123,255,0.3) !important;
        transform: translateY(-1px) !important;
    }
    
    .standard-btn:disabled {
        background: #cccccc !important;
        cursor: not-allowed !important;
        box-shadow: none !important;
        transform: none !important;
    }
    
    /* Action button improvements */
    .action-btn {
        color: white !important;
        font-weight: 500 !important;
        border: none !important;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3) !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        transition: all 0.2s !important;
    }
    
    .action-btn:hover {
        transform: translateY(-1px) !important;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
    }
    
    .enhanced-job-thumbnail { 
        width: 80px; 
        height: 80px; 
        object-fit: cover; 
        border-radius: 6px; 
        flex-shrink: 0; 
        background: #f0f0f0;
    }
    
    .enhanced-job-details-expanded .enhanced-job-thumbnail { 
        width: 300px; 
        height: 300px; 
        max-width: 90%;
        object-fit: contain;
    }
    
    /* Expanded job details should show larger media */
    .enhanced-job-item[data-expanded="true"] .enhanced-job-thumbnail,
    .job-details .enhanced-job-thumbnail,
    .job-details img,
    .job-details video {
        width: 100% !important;
        max-width: 500px !important;
        height: auto !important;
        max-height: 400px !important;
        object-fit: contain !important;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        margin: 10px 0;
    }
    
    /* Ensure videos display properly when expanded */
    .job-details video {
        background: #000;
    }
    
    /* Better styling for expanded images */
    .job-details img {
        border: 1px solid #e9ecef;
        background: #f8f9fa;
        display: block;
        margin: 15px auto;
    }
    
    /* Job Info Container */
    .job-info-container {
        flex-grow: 1;
        min-width: 0; /* Allow text truncation */
    }
    
    .job-title {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 4px 0;
        color: #333;
    }
    
    /* Scrollable Prompt Box */
    .job-prompt-box {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 6px 8px;
        max-height: 40px;
        overflow-y: auto;
        font-size: 12px;
        line-height: 1.3;
        color: #666;
        resize: vertical;
        min-height: 20px;
    }
    
    .job-prompt-box:hover {
        border-color: #007bff;
    }
    
    .job-status-badges {
        margin-top: 4px;
        display: flex;
        gap: 4px;
    }
    
    /* Preloader Animation */
    .content-placeholder { 
        width: 100%; 
        height: 200px; 
        background: linear-gradient(-90deg, #f0f0f0 0%, #e0e0e0 50%, #f0f0f0 100%); 
        background-size: 400% 400%; 
        animation: shimmer 2s ease-in-out infinite; 
        border-radius: 8px; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        color: #666; 
        font-weight: 600; 
    }
    
    @keyframes shimmer { 
        0% { background-position: 0% 0%; } 
        100% { background-position: -200% 0%; } 
    }
    
    /* Color Sampler Tool */
    .color-sampler { 
        display: flex; 
        align-items: center; 
        gap: 10px; 
        margin-top: 10px; 
    }
    
    .color-preview { 
        width: 40px; 
        height: 40px; 
        border: 2px solid #ddd; 
        border-radius: 6px; 
        cursor: pointer; 
    }
    
    /* Upload Areas */
    .upload-area { 
        border: 2px dashed #ddd; 
        border-radius: 8px; 
        padding: 40px 20px; 
        text-align: center; 
        transition: all 0.3s ease; 
        cursor: pointer; 
        background: #fafafa; 
    }
    
    .upload-area:hover, .upload-area.dragover { 
        border-color: #007bff; 
        background: #f0f8ff; 
    }
    
    /* Job Grouping - Improved */
    .grouped-job-container { 
        border-left: 4px solid #007bff; 
    }
    
    /* Stacked Image Thumbnails */
    .stacked-thumbnails {
        position: relative;
        width: 80px;
        height: 80px;
        flex-shrink: 0;
    }
    
    .stacked-thumbnail {
        position: absolute;
        width: 70px;
        height: 70px;
        object-fit: cover;
        border-radius: 6px;
        border: 2px solid #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .stacked-thumbnail:nth-child(1) { top: 0; left: 0; z-index: 3; }
    .stacked-thumbnail:nth-child(2) { top: 8px; left: 8px; z-index: 2; }
    .stacked-thumbnail:nth-child(3) { top: 16px; left: 16px; z-index: 1; }
    
    /* Group Actions - Separate from images */
    .group-actions-bar {
        display: flex;
        gap: 6px;
        padding: 10px 15px;
        background: #f0f8ff;
        border-top: 1px solid #e9ecef;
        flex-wrap: wrap;
    }
    
    .group-actions-bar button {
        font-size: 11px !important;
        padding: 4px 8px !important;
        min-height: 28px !important;
    }
    
    /* Individual Images with Only Checkboxes */
    .image-grid { 
        display: grid; 
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); 
        gap: 10px; 
        margin: 15px; 
        background: #fafafa;
        padding: 15px;
        border-radius: 6px;
    }
    
    .image-item { 
        position: relative; 
        border: 2px solid #e9ecef; 
        border-radius: 8px; 
        overflow: hidden; 
        transition: all 0.2s ease; 
        background: #fff;
    }
    
    
    .image-item:hover { 
        border-color: #007bff; 
        transform: translateY(-2px); 
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
    }
    
    .image-item img { 
        width: 100%; 
        height: 100px; 
        object-fit: cover; 
    }
    
    /* Only checkbox for individual images */
    .image-checkbox { 
        position: absolute; 
        top: 8px; 
        left: 8px; 
        width: 18px; 
        height: 18px; 
        z-index: 10; 
        background: rgba(255,255,255,0.9);
        border-radius: 3px;
    }
    
    /* Processing placeholder for images */
    .image-processing-placeholder {
        width: 100%;
        height: 100px;
        background: linear-gradient(-90deg, #f0f0f0 0%, #e0e0e0 50%, #f0f0f0 100%);
        background-size: 400% 400%;
        animation: shimmer 2s ease-in-out infinite;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        color: #666;
        font-weight: 600;
    }
    .job-log-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; margin-bottom: 15px; }
    .job-log-header h2 { margin: 0; padding-bottom: 10px; border-bottom: none; font-size: 18px; }
    
    .job-log-header-actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    .job-log-header-actions .action-btn,
    .job-log-header-actions .refresh-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 8px 12px;
        font-size: 13px;
        font-weight: 600;
        border-radius: 5px;
        border: none;
        cursor: pointer;
        color: white;
        white-space: nowrap;
        box-sizing: border-box;
    }
    #process-pending-btn { background-color: #28a745; }
    #process-selected-btn { display: none; background-color: #17a2b8; }
    #stitch-videos-btn { display: none; background-color: #6f42c1; }
    #delete-selected-btn { display: none; background-color: #dc3545; }
    #clear-failed-btn, #clear-stuck-btn, #clear-all-btn { background-color: #f8f9fa !important; color: #000000 !important; border: 1px solid #dee2e6; font-weight: 600; }
    #clear-failed-btn:hover, #clear-stuck-btn:hover, #clear-all-btn:hover { background-color: #e9ecef !important; color: #000000 !important; }
    .refresh-btn { background-color: #6c757d; }
    .refresh-btn.active { background-color: #28a745; }
    .refresh-btn.paused { background-color: #dc3545; }

    .log-item-wrapper { position: relative; }
    .selection-checkbox { position: absolute; top: 18px; left: 20px; z-index: 10; width: 18px; height: 18px; }
    .log-item { border: 1px solid #e9ecef; border-radius: 8px; margin-bottom: 10px; overflow: hidden; }
    .log-item.has-checkbox summary { padding-left: 45px; }
    .log-item summary { display: flex; align-items: center; gap: 8px; padding: 10px 15px; cursor: pointer; background-color: #f8f9fa; list-style: none; }
    .log-item summary::-webkit-details-marker { display: none; }
    .log-item-pills span { display: inline-flex; align-items: center; border-radius: 12px; padding: 4px 10px; font-size: 12px; font-weight: 600; color: #495057; white-space: nowrap; }
    .log-item-pills span:not(.status-badge) { background-color: #e9ecef; }
    .log-item-thumbnail { width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-left: 10px; }
    .log-item-prompt { font-size: 14px; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; margin-left: 10px; }
    .log-item-details { padding: 20px; display: grid; grid-template-columns: 300px 1fr; gap: 20px; border-top: 1px solid #e9ecef; }
    .log-details-visuals .thumbnail { width: 100%; height: auto; border-radius: 6px; margin-bottom: 15px; }
    .detail-preview-container { margin-top: 10px; }
    .detail-preview-image { max-width: 100%; max-height: 400px; height: auto; border-radius: 8px; display: block; margin: 0 auto; border: 1px solid #ddd; }
    .detail-preview-container video { margin-bottom: -5px; }
    .log-details-info h4 { margin: 0 0 10px 0; font-size: 14px; }
    .log-details-info pre { white-space: pre-wrap; background-color: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 13px; margin-bottom: 15px; max-height: 150px; overflow-y: auto; resize: vertical; }
    .error-message { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 6px; padding: 15px; margin-top: 10px; white-space: pre-wrap; }
    .log-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 15px; }
    .action-btn { text-decoration: none; color: white; padding: 6px 10px; border-radius: 4px; font-size: 12px; font-weight: 600; text-align: center; border: none; cursor: pointer; }
    .button-form { display: inline-block; }
    label { display: block; margin-bottom: 6px; font-weight: 600; color: #333; font-size: 13px; }
    .form-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
    .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    input, select, textarea { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ddd; box-sizing: border-box; font-size: 14px; font-family: inherit; }
    textarea { min-height: 100px; }
    .unlock-prompt-container { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
    .model-checkbox-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; }
    .model-checkbox-grid label { display: flex; align-items: center; padding: 6px 10px; background-color: #f8f9fa; border: 1px solid #ddd; border-radius: 5px; cursor: pointer; font-weight: normal; font-size: 13px; margin: 0; }
    .model-checkbox-grid input[type="checkbox"] { margin-right: 8px; width: auto; }
    button[type="submit"] { background-color: #007bff; color: white; border: none; padding: 12px 15px; font-size: 14px; font-weight: 600; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 15px; }
    .analysis-output-grid { display: grid; grid-template-columns: 150px 1fr; gap: 10px; margin-top: 10px; }
    .analysis-output-grid strong { text-align: right; padding-right: 10px; }
    .palette-swatch-container { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .palette-swatch { width: 60px; height: 60px; border-radius: 8px; border: 1px solid #eee; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; color: #333; position: relative; }
    .palette-swatch .color-box { width: 100%; height: 100%; border-radius: 8px; }
    .palette-swatch .color-label { position: absolute; bottom: 5px; background: rgba(255,255,255,0.8); padding: 2px 5px; border-radius: 3px; }
    
    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
    .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 700px; border-radius: 8px; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 20px; }
    .close-button { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
    #modal-video-container { width: 100%; background-color: #000; margin-bottom: 15px; }
    #modal-video-container video { width: 100%; height: auto; display: block; }
    .modal-controls { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 10px; }
    .modal-controls .frame-nav-btn { flex-basis: 100px; }
    .modal-controls .save-frame-btn { flex-grow: 1; background-color: #28a745; color: white; border: none; padding: 10px; font-weight: bold; border-radius: 5px; }
    
    /* Visual indicators for stuck/long-running jobs */
    .job-stuck-warning {
        animation: pulse-warning 2s infinite;
        border-left: 4px solid #ff6b6b !important;
    }
    @keyframes pulse-warning {
        0% { background-color: rgba(255, 107, 107, 0.1); }
        50% { background-color: rgba(255, 107, 107, 0.3); }
        100% { background-color: rgba(255, 107, 107, 0.1); }
    }
    .stuck-indicator {
        background-color: #ff6b6b;
        color: white;
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 5px;
    }
</style>

<div class="split-container">
    <!-- Left Panel - Dashboard Tools -->
    <div class="dashboard-panel">
<div class="main-header">
    <h1>AI Workflow Dashboard</h1>
            <p>All your tools in one place - results appear in the queue on the right.</p>
</div>

<details class="dashboard-section" id="analyzer-section">
    <summary>Style & Palette Analyzer</summary>
    <div class="tool-content">
        <div class="form-row">
            <div style="border-right: 1px solid #eee; padding-right: 15px;">
                <form action="/style-tool" method="post" enctype="multipart/form-data" onsubmit="enableStylePromptBeforeSubmit(this)">
                    <label for="image">Upload for Style Analysis:</label>
                    <input type="file" id="image" name="image" accept="image/*" required>
                    <div style="margin-top: 15px;">
                        <label for="style_system_prompt">System Prompt:</label>
                        <div class="text-field-container">
                        <textarea id="style_system_prompt" name="system_prompt" disabled>You are an Art Style Forensics analyzer.
Your description must be ≤ 1200 characters – be concise and omit any redundant words.

Describe only the artistic style, technique, and visual language so an AI image model can replicate it.

Never mention subject matter, color names, camera/lens/lighting.

Always stay factual and brief about style, surfaces, forms, treatment.

Avoid full sentences when not needed; use short phrases separated by semicolons.

Branching:

If drawing/painting/print → give Line & Stroke (weight_min/max %, variability, spacing %, edge quality, terminals, curvature); then note medium, textures, composition, tone, mood, negatives.

If photo → say "no line work; object style analysis applied instead"; then note movement/genre, form language, surfaces/materials, geometry, tone, mood, negatives.

If 3D render → say "no line work; 3D render style analysis applied instead"; then note shading style, surface treatment, geometry, visual finish, tone, mood, negatives.

Output order:
Medium → Technique/Process → Line / Object / 3D analysis → Textures & Surface → Composition & Shapes → Palette/Tone → Mood/Atmosphere → Negative Cues.

Keep each section to short declarative fragments to stay under limit.</textarea>
                            <button type="button" class="copy-btn" onclick="copyToClipboard('style_system_prompt')">⎘</button>
                        </div>
                        <div class="unlock-prompt-container">
                            <input type="checkbox" id="unlock_style_prompt"><label for="unlock_style_prompt" style="font-weight: normal; font-size: 12px;">Unlock to edit</label>
                        </div>
                    </div>
                    <button type="submit" class="standard-btn">Analyze Style</button>
                    
                    <!-- Style Analysis Output -->
                    <div id="style-output-section" style="margin-top: 20px; display: none;">
                        <label>Style Analysis Result:</label>
                        <div class="text-field-container">
                            <textarea id="style-analysis-result" readonly style="min-height: 120px; resize: both;"></textarea>
                            <button type="button" class="copy-btn" onclick="copyToClipboard('style-analysis-result')">⎘</button>
                        </div>
                        <button type="button" class="standard-btn" style="margin-top: 10px;" onclick="useStyleAnalysis()">Use This Style</button>
                    </div>
                </form>
            </div>
            <div style="padding-left: 15px;">
                <form action="/palette-tool" method="post" enctype="multipart/form-data" onsubmit="enablePalettePromptBeforeSubmit(this)">
                    <label for="palette_image">Upload for Palette Analysis:</label>
                    <input type="file" id="palette_image" name="image" accept="image/*" required>
                    <div style="margin-top: 15px;">
                        <label for="palette_system_prompt">System Prompt:</label>
                        <div class="text-field-container">
                        <textarea id="palette_system_prompt" name="system_prompt" disabled>Analyze the provided image and identify the 5 most prominent colors of the SUBJECT/FOREGROUND. 

IMPORTANT CHROMA KEY RULE: If both green AND blue colors appear in the image, EXCLUDE the less prominent one from the palette entirely. Skip it and move to the next color to maintain 5 total colors. This is because images will later be animated on green or blue screen backgrounds - we don't want the palette to include the future chroma key background color if it appears minimally in the original image.

Example: If analyzing a tree with green leaves (prominent) that also has a small blue sky area (less prominent), only include the green and skip the blue entirely, as blue will be used as the chroma key background later.

For each color, provide its hexadecimal code and a simple, descriptive name (e.g., 'dark slate blue', 'light coral'). Return the response as a valid JSON object with a single key "palette" which is an array of objects. Each object in the array should have two keys: "hex" and "name". Example: {"palette": [{"hex": "#2F4F4F", "name": "dark slate grey"}, ...]}</textarea>
                            <button type="button" class="copy-btn" onclick="copyToClipboard('palette_system_prompt')">⎘</button>
                        </div>
                        <div class="unlock-prompt-container">
                            <input type="checkbox" id="unlock_palette_prompt"><label for="unlock_palette_prompt" style="font-weight: normal; font-size: 12px;">Unlock to edit</label>
                        </div>
                    </div>
                    <button type="submit" class="standard-btn">Analyze Palette</button>
                    
                    <!-- Palette Analysis Output -->
                    <div id="palette-output-section" style="margin-top: 20px; display: none;">
                        <label>Palette Analysis Result:</label>
                        <div class="text-field-container">
                            <textarea id="palette-analysis-result" readonly style="min-height: 80px; resize: both;"></textarea>
                            <button type="button" class="copy-btn" onclick="copyToClipboard('palette-analysis-result')">⎘</button>
                        </div>
                        <button type="button" class="standard-btn" style="margin-top: 10px;" onclick="usePaletteAnalysis()">Use This Palette</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</details>

<details class="dashboard-section" id="generator-section" open>
    <summary>Image Generator</summary>
    <div class="tool-content">
        <form action="/image-tool" method="post" id="image-generator-form">
            <input type="hidden" name="parent_job_id" id="image-parent-job-id">
            <div class="form-grid">
                <div>
                    <label for="object_prompt">Object to Create:</label>
                    <div class="text-field-container">
                        <input type="text" id="object_prompt" name="object_prompt" placeholder="e.g., a vintage armchair" required>
                        <button type="button" class="copy-btn" onclick="copyToClipboard('object_prompt')">⎘</button>
                    </div>
                </div>
                <div>
                    <label for="style_prompt">Style Description:</label>
                    <div class="text-field-container">
                        <textarea id="style_prompt" name="style_prompt" required></textarea>
                        <button type="button" class="copy-btn" onclick="copyToClipboard('style_prompt')">⎘</button>
                    </div>
                </div>
                <div>
                    <label class="form-section-label">Generation Models:</label>
                    <div class="model-checkbox-grid">
                        <label><input type="checkbox" name="modelId" value="replicate-gpt-image-1" data-is-leonardo="false"> OpenAI on Replicate</label>
                        <label><input type="checkbox" name="modelId" value="bytedance-seedream-4" data-is-leonardo="false"> Bytedance Seedream-4</label>
                        <label><input type="checkbox" name="modelId" value="b24e16ff-06e3-43eb-8d33-4416c2d75876" data-is-leonardo="true" checked> Leonardo Diffusion XL</label>
                        <label><input type="checkbox" name="modelId" value="5c232a9e-9061-4777-980a-ddc8e65647c6" data-is-leonardo="true"> Leonardo Vision XL</label>
                        <label><input type="checkbox" name="modelId" value="2067ae52-33fd-4a82-bb92-c2c55e7d2786" data-is-leonardo="true"> AlbedoBase XL</label>
                    </div>
                </div>
                <div id="leonardo-options-container">
                    <div class="form-row">
                        <div>
                            <label for="presetStyle">Artistic Style (Leonardo Only):</label>
                            <select id="presetStyle" name="presetStyle">
                                <option value="NONE" selected>None</option>
                                <option value="CINEMATIC">Cinematic</option>
                                <option value="CREATIVE">Creative</option>
                                <option value="DYNAMIC">Dynamic</option>
                                <option value="ENVIRONMENT">Environment</option>
                                <option value="GENERAL">General</option>
                                <option value="ILLUSTRATION">Illustration</option>
                                <option value="PHOTOGRAPHY">Photography</option>
                                <option value="RAYTRACED">Raytraced</option>
                                <option value="RENDER_3D">3D Render</option>
                                <option value="SKETCH_BW">B&W Sketch</option>
                                <option value="SKETCH_COLOR">Color Sketch</option>
                                <option value="VIBRANT">Vibrant</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <button type="submit" class="standard-btn">Generate Images</button>
        </form>
    </div>
</details>

<details class="dashboard-section" id="animation-section">
    <summary>Create Animation</summary>
    <div class="tool-content">
        <div class="upload-area" onclick="document.getElementById('animation-image-upload').click()" style="padding: 15px; min-height: 60px;">
            <h4 style="margin: 0 0 5px 0; font-size: 14px;">📷 Upload Start Frame</h4>
            <p style="margin: 0; font-size: 12px; color: #666;">Click here or drag an image</p>
            <input type="file" id="animation-image-upload" accept="image/*" style="display: none;" onchange="handleAnimationImageUpload(this)">
        </div>
        <div id="animation-form-container" style="display: none;">
            <form action="/generate-animation" method="post" id="animation-form">
                <input type="hidden" name="image_url" id="animation_image_url">
                <input type="hidden" name="end_image_url" id="animation_end_image_url">
                <input type="hidden" name="parent_job_id" id="animation_parent_job_id">
                <input type="hidden" name="boomerang_automation" id="boomerang_automation_flag" value="false">
                
                <div class="image-preview-section" style="margin: 20px 0;">
                    <!-- Start Frame -->
                    <div id="start-frame-display" style="display: none; margin-bottom: 15px;">
                        <label style="font-weight: 600; display: block; margin-bottom: 5px;">Start Frame:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <img id="animation-preview" style="max-width: 120px; max-height: 90px; border-radius: 8px;">
                            <button type="button" onclick="removeStartFrame()" class="action-btn" style="background: #dc3545; font-size: 11px; padding: 4px 8px;">❌ Remove</button>
                        </div>
                    </div>
                    
                    <!-- End Frame Controls -->
                    <div id="end-frame-controls" style="display: none; margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 2px solid #007bff;">
                        <label style="font-weight: 600; display: block; margin-bottom: 8px; font-size: 14px; color: #007bff;">
                            🔄 End Frame (Optional - for ABA Loop Animation):
                        </label>
                        <p style="margin: 0 0 12px 0; font-size: 12px; color: #6c757d;">
                            Select a second image to create a seamless A→B→A loop animation
                        </p>
                        <div style="display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;">
                            <button type="button" onclick="openLibraryModal('animation-end')" class="standard-btn" style="background: #007bff;">📚 Library</button>
                            <button type="button" onclick="openJobSelectModal('animation-end')" class="standard-btn" style="background: #007bff;">📋 From Jobs</button>
                            <div class="upload-area" onclick="document.getElementById('end-frame-upload').click()" style="display: inline-flex; padding: 6px 10px; margin: 0; cursor: pointer; background: #007bff; color: white;">
                                <span>📷 Upload</span>
                                <input type="file" id="end-frame-upload" accept="image/*" style="display: none;" onchange="handleEndFrameUpload(this)">
                            </div>
                        </div>
                        <div id="end-frame-display" style="display: none;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <img id="animation-end-preview" style="max-width: 120px; max-height: 90px; border-radius: 8px;">
                                <button type="button" onclick="removeEndFrame()" class="action-btn" style="background: #dc3545; font-size: 11px; padding: 4px 8px;">❌ Remove</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label for="animation_prompt" style="margin: 0;">Animation Prompt:</label>
                        <button type="button" id="get-animation-idea-btn" class="standard-btn" onclick="getAnimationIdea()" style="padding: 6px 12px; font-size: 12px;">💡 Get Idea</button>
                    </div>
                    <div class="text-field-container">
                        <textarea id="animation_prompt" name="prompt" required placeholder="Describe the animation..."></textarea>
                        <button type="button" class="copy-btn" onclick="copyToClipboard('animation_prompt')">⎘</button>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="margin-bottom: 8px;">Background:</label>
                    <div class="background-options-horizontal">
                        <div class="background-option">
                            <input type="radio" name="background" value="default" checked id="bg-default" style="margin: 0;">
                            <label for="bg-default" style="margin: 0; line-height: 1.5;">As is</label>
                        </div>
                        <div class="background-option">
                            <input type="radio" name="background" value="green" id="bg-green" style="margin: 0;">
                            <label for="bg-green" style="margin: 0; line-height: 1.5;">Green Screen</label>
                        </div>
                        <div class="background-option">
                            <input type="radio" name="background" value="blue" id="bg-blue" style="margin: 0;">
                            <label for="bg-blue" style="margin: 0; line-height: 1.5;">Blue Screen</label>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label for="animation_negative_prompt">Negative Prompt:</label>
                    <div class="text-field-container">
                        <input type="text" name="negative_prompt" id="animation_negative_prompt" placeholder="blurry, watermark, text, deformed">
                        <button type="button" class="copy-btn" onclick="copyToClipboard('animation_negative_prompt')">⎘</button>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label>Video Models:</label>
                    <div class="model-checkbox-grid">
                        <label><input type="checkbox" name="video_model" value="kwaivgi/kling-v2.1" checked> Kling v2.1</label>
                        <label><input type="checkbox" name="video_model" value="bytedance/seedance-1-pro"> Seedance-1 Pro</label>
                    </div>
                </div>

                <div style="margin-bottom: 15px; display: flex; align-items: center;">
                    <input type="checkbox" name="seamless_loop" value="true" id="seamless_loop" style="margin-right: 8px; width: auto;">
                    <label for="seamless_loop" style="margin: 0;">Seamless Loop</label>
                </div>

                <button type="submit" class="standard-btn">Generate Animation</button>
            </form>
        </div>
    </div>
</details>

<details class="dashboard-section" id="keying-section">
    <summary>🎬 Video Keyer (Chroma Key)</summary>
    <div class="tool-content">
        <p style="font-size: 13px; color: #666; margin-bottom: 15px;">
            Select a video from your completed jobs to adjust chroma key settings and remove the background.
        </p>
        
        <div id="keying-tool-empty" style="padding: 20px; text-align: center; background: #f8f9fa; border-radius: 8px; color: #6c757d;">
            <p style="margin: 0;">No video loaded. Click "⚙️ Key Video" on any completed animation to start.</p>
        </div>
        
        <div id="keying-tool-container" style="display: none;">
            <div class="video-container" id="keying-video-container" style="width: 100%; aspect-ratio: 16/9; margin-bottom: 15px; border-radius: 8px; overflow: auto; display: flex; justify-content: center; align-items: center; background: repeating-conic-gradient(#ddd 0% 25%, #fff 0% 50%) 50% / 20px 20px; position: relative; cursor: crosshair;">
                <video id="keying-video-preview" playsinline controls style="max-width: 100%; max-height: 100%; object-fit: contain; transition: transform 0.2s;"></video>
                <img id="keying-image-preview" alt="Keying Preview" style="display: none; max-width: 100%; max-height: 100%; object-fit: contain; cursor: pointer; transition: transform 0.2s;" title="Click to return to video">
                <div id="color-sample-indicator" style="display: none; position: absolute; width: 30px; height: 30px; border: 3px solid white; border-radius: 50%; pointer-events: none; box-shadow: 0 0 10px rgba(0,0,0,0.5);"></div>
            </div>
            
            <!-- Quick Actions Row -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                <button type="button" id="reset-preview-btn" class="standard-btn" style="background: #6c757d; padding: 8px 12px; font-size: 11px; flex: 1; min-width: 120px;">🔄 Reset Preview</button>
                <button type="button" id="zoom-in-btn" class="standard-btn" style="background: #17a2b8; padding: 8px 12px; font-size: 11px; flex: 1; min-width: 120px;">🔍+ Zoom In</button>
                <button type="button" id="zoom-out-btn" class="standard-btn" style="background: #17a2b8; padding: 8px 12px; font-size: 11px; flex: 1; min-width: 120px;">🔍- Zoom Out</button>
                <button type="button" id="zoom-reset-btn" class="standard-btn" style="background: #17a2b8; padding: 8px 12px; font-size: 11px; flex: 1; min-width: 120px;">↺ Reset Zoom</button>
            </div>
            
            <!-- Color Sampler Tool -->
            <div style="background: #e3f2fd; padding: 10px; border-radius: 6px; margin-bottom: 15px; border: 2px solid #2196f3;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h4 style="margin: 0; font-size: 13px; color: #1976d2;">🎨 Color Sampler</h4>
                    <button type="button" id="toggle-sampler-btn" class="standard-btn" style="padding: 5px 10px; font-size: 11px; background: #2196f3;">Enable</button>
                </div>
                <div id="sampled-color-display" style="display: none; background: white; padding: 8px; border-radius: 4px; font-size: 11px;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div id="sampled-color-box" style="width: 40px; height: 40px; border: 2px solid #dee2e6; border-radius: 4px;"></div>
                        <div style="flex: 1;">
                            <div><strong>H:</strong> <span id="sampled-hue">0</span></div>
                            <div><strong>S:</strong> <span id="sampled-sat">0</span></div>
                            <div><strong>V:</strong> <span id="sampled-val">0</span></div>
                        </div>
                        <button type="button" id="apply-sampled-color-btn" class="standard-btn" style="padding: 5px 10px; font-size: 11px; background: #28a745;">Apply to Sliders</button>
                    </div>
                </div>
            </div>
            
            <div style="background-color: #f8f9fa; padding: 12px; border-radius: 8px;">
                <form id="keying-form">
                    <input type="hidden" id="keying-job-id" value="">
                    <input type="hidden" id="keying-video-path" value="">
                    
                    <h4 style="margin: 0 0 10px 0; font-size: 13px;">Keying Controls</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 15px; margin-bottom: 12px;">
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Hue Center: <span id="hue_center_val">60</span></label><input type="range" id="hue_center" name="hue_center" min="0" max="180" value="60" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Hue Tolerance: <span id="hue_tolerance_val">25</span></label><input type="range" id="hue_tolerance" name="hue_tolerance" min="0" max="50" value="25" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Saturation Min: <span id="saturation_min_val">50</span></label><input type="range" id="saturation_min" name="saturation_min" min="0" max="255" value="50" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Value Min: <span id="value_min_val">50</span></label><input type="range" id="value_min" name="value_min" min="0" max="255" value="50" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Choke/Erode: <span id="erode_val">0</span></label><input type="range" id="erode" name="erode" min="-5" max="5" value="0" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Soften/Dilate: <span id="dilate_val">0</span></label><input type="range" id="dilate" name="dilate" min="-5" max="5" value="0" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Edge Blur: <span id="blur_val">5</span></label><input type="range" id="blur" name="blur" min="0" max="21" value="5" step="2" style="width: 100%;"></div>
                        <div><label style="display: block; margin-bottom: 2px; font-weight: 600; font-size: 11px;">Spill Suppression: <span id="spill_val">2</span></label><input type="range" id="spill" name="spill" min="0" max="10" value="2" style="width: 100%;"></div>
                    </div>
                    
                    <div style="padding: 10px 0; border-top: 1px solid #dee2e6; margin-bottom: 10px;">
                        <h4 style="margin: 0 0 8px 0; font-size: 12px;">Background</h4>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                            <div><label style="display: block; font-size: 10px; margin-bottom: 3px;">Color 1:</label><input type="color" id="checkerColor1" value="#808080" style="width: 100%; height: 28px;"></div>
                            <div><label style="display: block; font-size: 10px; margin-bottom: 3px;">Color 2:</label><input type="color" id="checkerColor2" value="#c0c0c0" style="width: 100%; height: 28px;"></div>
                            <div><label style="display: block; font-size: 10px; margin-bottom: 3px;">Size:</label><input type="number" id="checkerSize" value="20" min="5" max="100" style="width: 100%; height: 28px; padding: 4px; font-size: 11px;"></div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
                        <button type="button" id="prev-frame-btn" class="standard-btn" style="padding: 6px; font-size: 11px;">◄ Prev</button>
                        <button type="button" id="next-frame-btn" class="standard-btn" style="padding: 6px; font-size: 11px;">Next ►</button>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                        <button type="button" id="keying-preview-btn" class="standard-btn" style="background: #007bff; padding: 8px; font-size: 11px;">🔍 Preview</button>
                        <button type="button" id="keying-save-btn" class="standard-btn" style="background: #28a745; padding: 8px; font-size: 11px;">💾 Save Settings</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</details>

<details class="dashboard-section" id="video-upload-section">
    <summary>Upload Video for Processing</summary>
    <div class="tool-content">
        <div class="form-row">
            <div style="border-right: 1px solid #eee; padding-right: 15px;">
                <h4>Green/Blue Screen Keying</h4>
                <div class="upload-area" onclick="document.getElementById('keying-video-upload').click()">
                    <h3>🎬 Upload Video</h3>
                    <p>Upload a video with green or blue screen for keying</p>
                    <input type="file" id="keying-video-upload" accept="video/*" style="display: none;" onchange="handleKeyingVideoUpload(this)">
                </div>
                
                <div class="color-sampler" style="margin-top: 15px;">
                    <label>Sample Color from Video:</label>
                    <div class="color-preview" id="sampled-color" style="background-color: #00ff00;"></div>
                    <button type="button" class="standard-btn" onclick="openColorSampler()">🎯 Sample</button>
                    <input type="color" id="manual-color-picker" value="#00ff00" style="width: 50px;">
                </div>
            </div>
            <div style="padding-left: 15px;">
                <h4>Frame Extraction</h4>
                <div class="upload-area" onclick="document.getElementById('extract-video-upload').click()">
                    <h3>📹 Upload Video</h3>
                    <p>Upload a video to extract specific frames</p>
                    <input type="file" id="extract-video-upload" accept="video/*" style="display: none;" onchange="handleExtractVideoUpload(this)">
                </div>
            </div>
        </div>
    </div>
</details>

<details class="dashboard-section" id="extract-frame-section">
    <summary>Extract Frame from Video</summary>
    <div class="tool-content">
        <div class="upload-area" id="extract-upload-area" onclick="document.getElementById('extract-video-upload').click()">
            <h3>🎬 Upload Video</h3>
            <p>Click here or drag a video to extract frames from it</p>
            <input type="file" id="extract-video-upload" accept="video/*" style="display: none;" onchange="handleExtractVideoUpload(this)">
        </div>
        <div id="extract-preview-container" style="display: none;">
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <button onclick="clearExtractVideo()" class="action-btn" style="background: #6c757d; font-size: 11px; padding: 4px 8px;">🗑️ Clear</button>
                <button onclick="document.getElementById('extract-video-upload').click()" class="action-btn" style="background: #17a2b8; font-size: 11px; padding: 4px 8px;">📁 Change Video</button>
            </div>
            <video id="extract-preview-video" style="width: 100%; max-height: 350px; border-radius: 8px; background: #000;" controls></video>
            <div style="margin-top: 15px;">
                <label style="font-weight: 600; margin-bottom: 8px; display: block;">Frame Time (seconds):</label>
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                    <input type="range" id="extract-frame-time" min="0" max="10" step="0.033" value="0" oninput="updateExtractPreview()" style="flex: 1;">
                    <input type="number" id="extract-frame-time-input" min="0" step="0.033" value="0" style="width: 80px;" onchange="updateExtractPreview()">
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <button onclick="stepFrame(-0.033)" class="action-btn" style="background: #6c757d; font-size: 11px; padding: 4px 8px;">◀ -1 Frame</button>
                    <button onclick="stepFrame(0.033)" class="action-btn" style="background: #6c757d; font-size: 11px; padding: 4px 8px;">+1 Frame ▶</button>
                    <button onclick="stepFrame(-1)" class="action-btn" style="background: #6c757d; font-size: 11px; padding: 4px 8px;">◀◀ -1s</button>
                    <button onclick="stepFrame(1)" class="action-btn" style="background: #6c757d; font-size: 11px; padding: 4px 8px;">+1s ▶▶</button>
                </div>
            </div>
            <button onclick="extractCurrentFrame()" class="action-btn" style="background: #007bff; margin-top: 10px; width: 100%;">🖼️ Extract This Frame</button>
        </div>
    </div>
</details>

<details class="dashboard-section" id="stitcher-section">
    <summary>Video Stitcher</summary>
    <div class="tool-content">
        <p>Select two videos from the Job Queue on the right by checking their boxes, then use the "Stitch Selected Videos" button.</p>
    </div>
</details>

    </div>
    
    <!-- Resizable Divider -->
    <div class="divider" id="resizer"></div>
    
    <!-- Right Panel - Job Queue -->
    <div class="queue-panel">
        <div class="job-queue-header">
            <h2>Job Queue</h2>
            <div class="queue-actions">
                <button id="delete-selected-btn" class="action-btn" disabled>🗑️ Delete Selected (0)</button>
                <button id="stitch-videos-btn" class="action-btn" disabled>🎬 Stitch Selected Videos (0)</button>
                <button id="process-pending-btn" class="action-btn">⚙️ Process Pending Keys</button>
            <button id="process-selected-btn" class="action-btn" style="display: none;">⚙️ Process Selected Keys (0)</button>
                <button id="clear-failed-btn" class="action-btn">🧹 Clear Failed</button>
                <button id="clear-stuck-btn" class="action-btn">⚠️ Clear Stuck</button>
                <button id="clear-all-btn" class="action-btn">🗑️ Clear All Jobs</button>
            <button id="refresh-log-btn" class="refresh-btn active">⏸️ Pause Auto-Refresh</button>
        </div>
    </div>
    <div id="job-log-body"><p>Loading job history...</p></div>
    </div>
</div>

<!-- Color Sampler Modal -->
<div id="color-sampler-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Color Sampler</h2>
            <span class="close-button" onclick="closeColorSampler()">&times;</span>
        </div>
        <div id="color-sampler-video-container"></div>
        <div>
            <button onclick="selectSampledColor()" class="standard-btn">Use This Color</button>
        </div>
    </div>
</div>

<div id="extract-frame-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Extract Frame</h2>
            <span class="close-button">&times;</span>
        </div>
        <div id="modal-video-container"></div>
        <div class="modal-controls">
            <button id="modal-prev-frame-btn" class="frame-nav-btn">◄ Prev Frame</button>
            <button id="modal-save-frame-btn" class="save-frame-btn">Save This Frame</button>
            <button id="modal-next-frame-btn" class="frame-nav-btn">Next Frame ►</button>
        </div>
        <input type="hidden" id="modal-parent-job-id">
    </div>
</div>

<!-- Image popup modal -->
<div id="imageModal" class="image-modal">
    <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
    <button class="image-modal-nav image-modal-prev" onclick="navigateModalImage(-1)">❮</button>
    <button class="image-modal-nav image-modal-next" onclick="navigateModalImage(1)">❯</button>
    <div class="image-modal-content" id="imageModalContent">
        <img id="modalImage" src="" alt="Enlarged view">
    </div>
    <div id="imageModalCounter" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 14px; background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px;"></div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    // Debug mode - set to false for production
    window.DEBUG_MODE = true;
    
    // Enhanced error handling system
    function showUserFriendlyError(message, details = null, type = 'error') {
        if (type === 'error') {
            console.error('Application Error:', details || message);
        } else {
            console.log('Application Message:', message);
        }
        
        // Create a more user-friendly notification
        const notification = document.createElement('div');
        const isSuccess = type === 'success';
        const bgColor = isSuccess ? '#28a745' : '#dc3545';
        const icon = isSuccess ? '✅' : '⚠️';
        const title = isSuccess ? 'Success' : 'Error';
        
        notification.style.cssText = `
            position: fixed; top: 20px; right: 20px; z-index: 10000;
            background: ${bgColor}; color: white; padding: 15px 20px;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 400px; font-size: 14px; line-height: 1.4;
        `;
        notification.innerHTML = `
            <strong>${icon} ${title}:</strong> ${message}
            <button onclick="this.parentElement.remove()" style="
                float: right; background: none; border: none; color: white;
                font-size: 18px; cursor: pointer; margin-left: 10px;
            ">&times;</button>
        `;
        document.body.appendChild(notification);
        
        // Auto-remove after 4 seconds for success, 6 for errors
        const duration = isSuccess ? 4000 : 6000;
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, duration);
    }

    // Copy to clipboard function
    function copyToClipboard(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
            element.select();
            document.execCommand('copy');
            
            // Visual feedback
            const copyBtn = element.parentNode.querySelector('.copy-btn');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = '✓';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 1000);
        }
    }

    // Use analysis result function
    function useAnalysisResult(jobId) {
        // Find the result text directly from the DOM
        const button = event.target;
        const resultContainer = button.closest('.enhanced-job-media');
        const resultDiv = resultContainer?.querySelector('div[style*="white-space: pre-wrap"]');
        
        if (!resultDiv || !resultDiv.textContent.trim()) {
            showUserFriendlyError('Analysis result not found in the display');
            return;
        }

        const resultText = resultDiv.textContent.trim();

        // Determine job type from the button's parent elements
        const jobCard = button.closest('.enhanced-job-item');
        const jobTitle = jobCard?.querySelector('.job-title')?.textContent || '';
        const isAnimationIdea = jobTitle.includes('animation prompting');
        const isPaletteAnalysis = jobTitle.includes('palette');
        
        // For animation idea, place in animation prompt field
        if (isAnimationIdea) {
            const animationPromptField = document.getElementById('animation_prompt');
            if (!animationPromptField) {
                showUserFriendlyError('Animation prompt field not found. Please make sure the Animation section is visible.');
                return;
            }
            
            animationPromptField.value = resultText;
            
            // Visual feedback
            const originalText = button.textContent;
            button.textContent = '✓ Copied!';
            button.style.background = '#198754';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#28a745';
            }, 2000);

            // Scroll to the animation section
            const animationSection = document.getElementById('animation-section');
            if (animationSection) {
                animationSection.setAttribute('open', '');
                animationSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            showUserFriendlyError('Animation idea copied to Animation Creator!', null, 'success');
            return;
        }
        
        // For style/palette analysis, place in image generation style field
        const styleField = document.getElementById('style_prompt');
        if (!styleField) {
            showUserFriendlyError('Style prompt field not found. Please make sure the Image Generation section is visible.');
            return;
        }
        
        // For palette analysis, append to existing text; for style analysis, replace
        let actionMessage = '';
        if (isPaletteAnalysis && styleField.value.trim()) {
            // Append palette analysis to existing style description
            styleField.value = styleField.value.trim() + '\n\n' + resultText;
            actionMessage = 'Palette analysis appended to style prompt field!';
        } else {
            // Replace for style analysis or if field is empty
            styleField.value = resultText;
            actionMessage = 'Analysis result copied to style prompt field!';
        }
        
        // Visual feedback
        const originalText = button.textContent;
        button.textContent = isPaletteAnalysis && styleField.value.includes(resultText) ? '✓ Appended!' : '✓ Copied!';
        button.style.background = '#198754';
        
        setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#28a745';
        }, 2000);

        // Scroll to the image generation section
        const imageGenSection = document.querySelector('#generator-section') || document.querySelector('[data-section="image-generation"]');
        if (imageGenSection) {
            imageGenSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Show success message
        showUserFriendlyError(actionMessage, null, 'success');
    }

    // Enable style prompt before form submission
    function enableStylePromptBeforeSubmit(form) {
        const stylePromptTextarea = form.querySelector('#style_system_prompt');
        if (stylePromptTextarea && stylePromptTextarea.disabled) {
            stylePromptTextarea.disabled = false;
        }
        return true; // Allow form submission to continue
    }

    // Enable palette prompt before form submission
    function enablePalettePromptBeforeSubmit(form) {
        const palettePromptTextarea = form.querySelector('#palette_system_prompt');
        if (palettePromptTextarea && palettePromptTextarea.disabled) {
            palettePromptTextarea.disabled = false;
        }
        return true; // Allow form submission to continue
    }
    
    // Image modal functions
    let currentModalImageIndex = 0;
    let modalImageList = [];
    
    window.openImageModal = function(imageSrc) {
        const modal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalContent = document.getElementById('imageModalContent');
        const counter = document.getElementById('imageModalCounter');
        
        // Collect all clickable images on the page
        modalImageList = [];
        document.querySelectorAll('.clickable-image').forEach(img => {
            if (img.src) {
                modalImageList.push(img.src);
            } else {
                // Extract from onclick attribute (handles event.stopPropagation(); openImageModal(...))
                const onclick = img.getAttribute('onclick');
                if (onclick) {
                    const match = onclick.match(/openImageModal\(['"](.*?)['"]\)/);
                    if (match && match[1]) {
                        // Ensure the path starts with /
                        const path = match[1].startsWith('/') ? match[1] : '/' + match[1];
                        modalImageList.push(path);
                    }
                }
            }
        });
        
        // Remove duplicates
        modalImageList = [...new Set(modalImageList)];
        
        console.log('📸 Found images:', modalImageList.length);
        console.log('📸 Image list:', modalImageList);
        
        // Normalize imageSrc to path only (remove domain if present)
        let normalizedImageSrc = imageSrc;
        try {
            const url = new URL(imageSrc);
            normalizedImageSrc = url.pathname;
        } catch (e) {
            // Already a path, not a full URL
            if (!normalizedImageSrc.startsWith('/')) {
                normalizedImageSrc = '/' + normalizedImageSrc;
            }
        }
        
        console.log('🔍 Looking for:', normalizedImageSrc);
        
        // Find current image index
        currentModalImageIndex = modalImageList.findIndex(src => {
            // Normalize src for comparison
            let normalizedSrc = src;
            try {
                const url = new URL(src);
                normalizedSrc = url.pathname;
            } catch (e) {
                // Already a path
            }
            return normalizedSrc === normalizedImageSrc;
        });
        
        if (currentModalImageIndex === -1) {
            currentModalImageIndex = 0;
            modalImageList = [normalizedImageSrc];
            console.log('⚠️ Image not in list, using single image');
        } else {
            console.log('✅ Current image index:', currentModalImageIndex + 1, 'of', modalImageList.length);
        }
        
        // Load image (use the normalized path)
        const imageToLoad = currentModalImageIndex >= 0 && currentModalImageIndex < modalImageList.length 
            ? modalImageList[currentModalImageIndex] 
            : normalizedImageSrc;
        modalImage.src = imageToLoad;
        
        // Check for transparency after image loads
        modalImage.onload = function() {
            checkImageTransparency(imageToLoad, modalContent);
        };
        
        // Update counter
        counter.textContent = `${currentModalImageIndex + 1} / ${modalImageList.length}`;
        counter.style.display = modalImageList.length > 1 ? 'block' : 'none';
        
        // Show/hide navigation buttons
        document.querySelector('.image-modal-prev').style.display = modalImageList.length > 1 ? 'block' : 'none';
        document.querySelector('.image-modal-next').style.display = modalImageList.length > 1 ? 'block' : 'none';
        
        modal.style.display = 'block';
        
        // Close modal on background click
        modal.onclick = function(event) {
            if (event.target === modal) {
                closeImageModal();
            }
        };
        
        // Handle keyboard navigation
        document.addEventListener('keydown', handleModalKeypress);
    };
    
    function handleModalKeypress(event) {
        if (document.getElementById('imageModal').style.display === 'block') {
            if (event.key === 'Escape') {
                closeImageModal();
            } else if (event.key === 'ArrowLeft') {
                navigateModalImage(-1);
            } else if (event.key === 'ArrowRight') {
                navigateModalImage(1);
            }
        }
    }
    
    window.navigateModalImage = function(direction) {
        console.log('🔄 Navigate called:', direction > 0 ? 'next' : 'previous');
        console.log('   Current index:', currentModalImageIndex, 'Total images:', modalImageList.length);
        
        if (modalImageList.length <= 1) {
            console.log('⚠️ Not enough images to navigate');
            return;
        }
        
        currentModalImageIndex += direction;
        
        // Wrap around
        if (currentModalImageIndex < 0) {
            currentModalImageIndex = modalImageList.length - 1;
            console.log('↩️ Wrapped to end:', currentModalImageIndex);
        } else if (currentModalImageIndex >= modalImageList.length) {
            currentModalImageIndex = 0;
            console.log('↪️ Wrapped to start:', currentModalImageIndex);
        }
        
        const modalImage = document.getElementById('modalImage');
        const modalContent = document.getElementById('imageModalContent');
        const counter = document.getElementById('imageModalCounter');
        
        const newImage = modalImageList[currentModalImageIndex];
        console.log('📸 Loading image:', newImage);
        modalImage.src = newImage;
        
        // Check for transparency
        modalImage.onload = function() {
            checkImageTransparency(modalImageList[currentModalImageIndex], modalContent);
        };
        
        // Update counter
        counter.textContent = `${currentModalImageIndex + 1} / ${modalImageList.length}`;
    };
    
    function checkImageTransparency(imageSrc, container) {
        // Check if image has transparent background by file extension or path
        const hasTransparency = imageSrc.match(/\.(png|webp)$/i) && 
                               (imageSrc.includes('background_removal') || 
                                imageSrc.includes('keyed') || 
                                imageSrc.includes('/library/'));
        
        if (hasTransparency) {
            container.classList.add('has-transparency');
        } else {
            container.classList.remove('has-transparency');
        }
    }
    
    window.closeImageModal = function() {
        const modal = document.getElementById('imageModal');
        modal.style.display = 'none';
        document.removeEventListener('keydown', handleModalKeypress);
    };
    
    // Make images clickable for popup viewing
    function makeImageClickable(imgElement) {
        if (!imgElement) return;
        imgElement.classList.add('clickable-image');
        imgElement.onclick = function(e) {
            e.stopPropagation(); // Prevent event bubbling
            openImageModal(this.src);
        };
    }
    
    // Copy job prompt function
    function copyJobPrompt(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
            element.select();
            document.execCommand('copy');
            
            // Visual feedback
            const copyBtn = element.parentNode.querySelector('.copy-btn');
            if (copyBtn) {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '✓';
                copyBtn.style.color = '#28a745';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.color = '';
                }, 1000);
            }
        }
    }
    
    // Style and Palette Analysis Functions
    function showStyleOutput(result) {
        document.getElementById('style-analysis-result').value = result;
        document.getElementById('style-output-section').style.display = 'block';
    }
    
    function showPaletteOutput(result) {
        document.getElementById('palette-analysis-result').value = result;
        document.getElementById('palette-output-section').style.display = 'block';
    }
    
    function useStyleAnalysis() {
        const result = document.getElementById('style-analysis-result').value;
        document.getElementById('style_prompt').value = result;
        alert('Style description copied to Image Generator!');
    }
    
    function usePaletteAnalysis() {
        const result = document.getElementById('palette-analysis-result').value;
        // Could be used to set color palette or added to style prompt
        const currentStyle = document.getElementById('style_prompt').value;
        const newStyle = currentStyle ? currentStyle + ' ' + result : result;
        document.getElementById('style_prompt').value = newStyle;
        alert('Palette description added to Image Generator!');
    }
    
    // Animation image upload handler
    function handleAnimationImageUpload(input) {
        if (input.files && input.files[0]) {
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                document.getElementById('animation-preview').src = e.target.result;
                document.getElementById('start-frame-display').style.display = 'block';
                document.getElementById('end-frame-controls').style.display = 'block';
                document.getElementById('animation-form-container').style.display = 'block';
                
                // Upload the file to the server
                uploadImageFile(file, 'animation_image_url');
            };
            
            reader.readAsDataURL(file);
        }
    }
    
    function handleEndFrameUpload(input) {
        if (input.files && input.files[0]) {
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                document.getElementById('animation-end-preview').src = e.target.result;
                document.getElementById('end-frame-display').style.display = 'block';
                
                // Enable boomerang automation flag
                const boomerangFlag = document.getElementById('boomerang_automation_flag');
                if (boomerangFlag) {
                    boomerangFlag.value = 'true';
                    console.log('✅ Boomerang automation enabled for ABA loop');
                }
                
                // Upload the file to the server  
                uploadImageFile(file, 'animation_end_image_url');
                
                // Show success message
                setTimeout(() => {
                    alert('✅ End frame uploaded! This will create an ABA-style loop animation.\n\nThe system will:\n1. Animate A→B (start to end)\n2. Animate B→A (end to start)\n3. Stitch them together into a seamless loop');
                }, 500);
            };
            
            reader.readAsDataURL(file);
        }
    }
    
    function removeStartFrame() {
        document.getElementById('start-frame-display').style.display = 'none';
        document.getElementById('end-frame-controls').style.display = 'none';
        document.getElementById('animation-form-container').style.display = 'none';
        document.getElementById('animation_image_url').value = '';
        document.getElementById('animation_parent_job_id').value = '';
        
        // Reset the file input
        document.getElementById('animation-image-upload').value = '';
    }
    
    function removeEndFrame() {
        document.getElementById('end-frame-display').style.display = 'none';
        document.getElementById('animation_end_image_url').value = '';
        
        // Disable boomerang automation flag
        const boomerangFlag = document.getElementById('boomerang_automation_flag');
        if (boomerangFlag) {
            boomerangFlag.value = 'false';
            console.log('✅ Boomerang automation disabled');
        }
        
        // Reset the file input
        document.getElementById('end-frame-upload').value = '';
    }
    
    function openJobSelectModal(target) {
        // This would open a modal to select from job results
        alert('Job Selection: This feature will allow you to select an image from your completed jobs as an end frame.');
    }
    
    // Video upload handlers
    function handleKeyingVideoUpload(input) {
        if (input.files && input.files[0]) {
            uploadVideoFile(input.files[0], 'keying');
        }
    }
    
    function handleExtractVideoUpload(input) {
        if (input.files && input.files[0]) {
            uploadVideoFile(input.files[0], 'extract');
        }
    }
    
    // File upload utility
    function uploadImageFile(file, targetInputId) {
        const formData = new FormData();
        formData.append('image', file);
        
        fetch('/upload-for-animation', {
            method: 'POST',
            body: formData
        })
        .then(response => response.text())
        .then(data => {
            // Extract URL from redirect response
            const urlMatch = data.match(/image_url=([^"&]+)/);
            if (urlMatch) {
                document.getElementById(targetInputId).value = decodeURIComponent(urlMatch[1]);
            }
        })
        .catch(error => console.error('Upload error:', error));
    }
    
    function uploadVideoFile(file, purpose) {
        const formData = new FormData();
        formData.append('video', file);
        formData.append('purpose', purpose);
        
        // Create a placeholder job to show upload progress
        showPlaceholder(`Uploading video for ${purpose}...`);
        
        fetch('/upload-video', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                if (purpose === 'keying') {
                    openKeyingInterface(data.job_id); // Pass job ID, not video path
                } else if (purpose === 'extract') {
                    openExtractFrameModal(data.video_path);
                }
            } else {
                alert('Upload failed: ' + data.error);
            }
        })
        .catch(error => {
            showUserFriendlyError('Upload failed. Please try again.', error);
        });
    }
    
    // Color sampler functionality
    let currentSamplerVideo = null;
    let sampledColor = '#00ff00';
    
    function openColorSampler() {
        const modal = document.getElementById('color-sampler-modal');
        modal.style.display = 'block';
        
        // If there's a video uploaded for keying, use it for sampling
        // Otherwise, show upload option
        const container = document.getElementById('color-sampler-video-container');
        container.innerHTML = '<p>Upload a video in the keying section first, then use this tool to sample colors.</p>';
    }
    
    function closeColorSampler() {
        document.getElementById('color-sampler-modal').style.display = 'none';
    }
    
    function selectSampledColor() {
        document.getElementById('sampled-color').style.backgroundColor = sampledColor;
        document.getElementById('manual-color-picker').value = sampledColor;
        closeColorSampler();
    }
    
    // Placeholder animation
    function showPlaceholder(message) {
        const placeholder = document.createElement('div');
        placeholder.className = 'content-placeholder';
        placeholder.textContent = message;
        
        // Add to job queue
        const logBody = document.getElementById('job-log-body');
        if (logBody) {
            logBody.insertBefore(placeholder, logBody.firstChild);
            
            // Remove after a few seconds
            setTimeout(() => {
                if (placeholder.parentNode) {
                    placeholder.parentNode.removeChild(placeholder);
                }
            }, 5000);
        }
    }
    
    // Keep frame extraction modal open
    let keepExtractModalOpen = false;
    
    // Enhanced job rendering with grouping
    function renderGroupedJobs(jobs) {
        // Group image_generation jobs by creation time (within 5 seconds of each other)
        const grouped = {};
        const imageGenJobs = jobs.filter(job => job.job_type === 'image_generation');
        
        // Sort by creation time
        imageGenJobs.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
        
        // Group jobs created within 5 seconds of each other
        imageGenJobs.forEach(job => {
            const jobTime = new Date(job.created_at).getTime();
            let foundGroup = false;
            
            // Check if this job belongs to an existing group
            Object.keys(grouped).forEach(groupKey => {
                const groupTime = parseInt(groupKey);
                const timeDiff = Math.abs(jobTime - groupTime) / 1000; // difference in seconds
                
                if (timeDiff <= 5) { // Jobs created within 5 seconds are grouped together
                    grouped[groupKey].push(job);
                    foundGroup = true;
                }
            });
            
            // If no group found, create a new group
            if (!foundGroup) {
                grouped[jobTime] = [job];
            }
        });
        
        // Create a map: jobId -> group (for multi-job groups only)
        const jobIdToGroup = new Map();
        Object.values(grouped).forEach(group => {
            if (group.length > 1) {
                group.forEach(job => jobIdToGroup.set(job.id, group));
            }
        });
        
        // Track which groups we've already rendered
        const renderedGroups = new Set();
        
        // Interleave grouped and non-grouped jobs by creation time
        let html = '';
                jobs.forEach(job => {
            if (job.job_type === 'image_generation') {
                const group = jobIdToGroup.get(job.id);
                
                if (group) {
                    // This job is part of a multi-job group
                    // Only render the group once (when we encounter the first job)
                    if (!renderedGroups.has(group)) {
                        html += renderJobGroup(group);
                        renderedGroups.add(group);
                    }
                    // Skip individual rendering since it's part of a group
                } else {
                    // Single image generation job, render normally
                    html += renderSingleJob(job);
                }
            } else {
                // Non-image-generation job, render normally
                html += renderSingleJob(job);
            }
        });
        
        return html;
    }
    
    function renderJobGroup(jobs) {
        const firstJob = jobs[0];
        const allCompleted = jobs.every(job => job.status === 'completed');
        const completedJobs = jobs.filter(job => job.status === 'completed' && job.result_data);
        
        // Create stacked thumbnails for completed jobs
        let stackedThumbnailsHTML = '<div class="stacked-thumbnails">';
        completedJobs.slice(0, 3).forEach((job, index) => {
            stackedThumbnailsHTML += `<img src="/${job.result_data}" class="stacked-thumbnail clickable-image" alt="Generated Image" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')">`;
        });
        stackedThumbnailsHTML += '</div>';
        
        let html = `
            <div class="enhanced-job-item grouped-job-container">
                <div class="enhanced-job-summary" onclick="toggleJobDetails(this)">
                    <input type="checkbox" class="job-selection-checkbox selection-checkbox" data-group-ids="${jobs.map(j => j.id).join(',')}" onclick="event.stopPropagation()">
                    <div class="job-number-badge">Group</div>
                    ${completedJobs.length > 0 ? stackedThumbnailsHTML : '<div class="enhanced-job-thumbnail content-placeholder">Processing...</div>'}
                    <div class="job-info-container">
                        <h4 class="job-title">Image Generation (${jobs.length} models)</h4>
                        <div class="job-prompt-box">${firstJob.prompt}</div>
                        <div class="job-status-badges">
        `;
        
        jobs.forEach(job => {
            html += `<span class="status-badge status-${job.status}">${job.status}</span>`;
        });
        
        html += `
                        </div>
                    </div>
                </div>
                <div class="job-details" style="display: none; padding: 15px; border-top: 1px solid #e9ecef;">
                    <!-- Group Actions Bar -->
                    <div class="group-actions-bar">
                        <button class="action-btn" onclick="animateGroupImages([${completedJobs.map(j => j.id).join(',')}])" style="background: #007bff;">🎬 Animate Selected</button>
                        <button class="action-btn" onclick="removeBgGroup([${completedJobs.map(j => j.id).join(',')}])" style="background: #17a2b8;">✨ Remove BG Selected</button>
                        <button class="action-btn" onclick="regenerateGroup([${jobs.map(j => j.id).join(',')}])" style="background: #6f42c1;">🔄 Regenerate Group</button>
                        <button class="action-btn" onclick="deleteGroup([${jobs.map(j => j.id).join(',')}])" style="background: #dc3545;">🗑️ Delete Group</button>
                    </div>
                    
                    <!-- Group Details -->
                    <div class="enhanced-job-content" style="margin: 15px 0;">
                        <div class="enhanced-job-text">
                            <label style="font-weight: 600; margin-bottom: 8px; display: block;">Prompt:</label>
                            <div style="position: relative;">
                                <textarea class="job-prompt-box" readonly id="group-prompt-${firstJob.id}">${firstJob.prompt || 'No prompt available'}</textarea>
                                <button class="copy-btn" onclick="copyJobPrompt('group-prompt-${firstJob.id}')" title="Copy prompt">⎘</button>
                            </div>
                            <div style="margin-top: 15px; font-size: 12px; color: #666;">
                                <p><strong>Created:</strong> ${new Date(firstJob.created_at).toLocaleString()}</p>
                                <p><strong>Models:</strong> ${jobs.length} different models</p>
                                <p><strong>Completed:</strong> ${completedJobs.length} / ${jobs.length}</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Individual Images Grid -->
                    <div class="image-grid">
        `;
        
        jobs.forEach(job => {
            if (job.status === 'completed' && job.result_data) {
                html += `
                    <div class="image-item">
                        <input type="checkbox" class="image-checkbox selection-checkbox" data-job-id="${job.id}">
                        <img src="/${job.result_data}" alt="Generated Image" class="clickable-image" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')">
                    </div>
                `;
                } else {
                html += `
                    <div class="image-item">
                        <div class="image-processing-placeholder">${job.status}</div>
                    </div>
                `;
            }
        });
        
        html += `
                    </div>
                </div>
            </div>
        `;
        
        return html;
    }
    
    function renderSingleJob(job) {
        // Enhanced single job rendering with proper video support
        const isExpanded = false; 
        const thumbnailClass = isExpanded ? 'enhanced-job-details-expanded' : '';
        
        let thumbnailHTML = '';
        
        // Handle analysis jobs differently - they show the input image and analysis result
        if (job.job_type === 'style_analysis' || job.job_type === 'palette_analysis' || job.job_type === 'animation_prompting') {
            // For analysis jobs, always try to show the input image as thumbnail
            try {
                const inputData = JSON.parse(job.input_data || '{}');
                const imagePath = inputData.image_path;
                if (imagePath) {
                    thumbnailHTML = `<img src="/${imagePath}" class="enhanced-job-thumbnail ${thumbnailClass} clickable-image" alt="Analysis Input" onclick="event.stopPropagation(); openImageModal('/${imagePath}')">`;
                } else if (job.result_data && job.result_data.includes('static/uploads/')) {
                    // Fallback: for old jobs where result_data contains the image path
                    thumbnailHTML = `<img src="/${job.result_data}" class="enhanced-job-thumbnail ${thumbnailClass} clickable-image" alt="Analysis Input" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')">`;
                } else if (job.status === 'completed') {
                    thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #d4edda; color: #155724; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;">Analysis Complete</div>`;
                }
            } catch (e) {
                // If parsing fails, try to use result_data as image path for old jobs
                if (job.result_data && job.result_data.includes('static/uploads/')) {
                    thumbnailHTML = `<img src="/${job.result_data}" class="enhanced-job-thumbnail ${thumbnailClass} clickable-image" alt="Analysis Input" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')">`;
                } else if (job.status === 'completed') {
                    thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #d4edda; color: #155724; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 11px;">Analysis Complete</div>`;
                }
            }
            
            if (!thumbnailHTML) {
                if (job.status === 'processing' || job.status === 'keying_processing') {
                    thumbnailHTML = `<div class="content-placeholder enhanced-job-thumbnail ${thumbnailClass}">Analyzing...</div>`;
                } else if (job.status === 'failed') {
                    thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #f8d7da; color: #721c24; display: flex; align-items: center; justify-content: center; font-weight: bold;">Failed</div>`;
                } else {
                    thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #e9ecef; display: flex; align-items: center; justify-content: center; font-size: 11px;">${job.status}</div>`;
                }
            }
        } else if (job.result_data && (job.status === 'completed' || job.status === 'pending_review' || job.status === 'pending_process')) {
            // Check if it's a video file
            const isVideoJob = job.job_type === 'animation' || job.job_type === 'video_stitching' || job.job_type === 'video_upload' || job.job_type === 'uploaded_video_keying';
            const hasVideoExtension = job.result_data.match(/\.(mp4|webm|mov)$/i);
            
            if (isVideoJob || hasVideoExtension) {
                // Show keyed video if it exists, otherwise show original
                const videoPath = job.keyed_result_data 
                    ? (job.keyed_result_data.startsWith('/') ? job.keyed_result_data : '/' + job.keyed_result_data)
                    : (job.result_data.startsWith('/') ? job.result_data : '/' + job.result_data);
                
                // Add timestamp to prevent caching issues
                const cacheBuster = '?t=' + Date.now();
                
                const pendingIcon = job.status === 'pending_process' ? '<div style="position: absolute; top: 5px; right: 5px; background: rgba(156, 39, 176, 0.95); color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">⏸</div>' : '';
                const keyedIcon = job.keyed_result_data ? '<div style="position: absolute; top: 5px; left: 5px; background: rgba(40, 167, 69, 0.95); color: white; border-radius: 4px; padding: 3px 8px; font-size: 10px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">KEYED</div>' : '';
                thumbnailHTML = `<div style="position: relative; display: inline-block;">${pendingIcon}${keyedIcon}<video src="${videoPath}${cacheBuster}" class="enhanced-job-thumbnail ${thumbnailClass}" playsinline muted loop autoplay preload="auto" style="object-fit: cover;"></video></div>`;
            } else {
                const pendingIcon = job.status === 'pending_process' ? '<div style="position: absolute; top: 5px; right: 5px; background: rgba(156, 39, 176, 0.95); color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">⏸</div>' : '';
                thumbnailHTML = `<div style="position: relative; display: inline-block;">${pendingIcon}<img src="/${job.result_data}" class="enhanced-job-thumbnail ${thumbnailClass} clickable-image" alt="Result" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')"></div>`;
            }
        } else if (job.status === 'processing' || job.status === 'keying_processing') {
            thumbnailHTML = `<div class="content-placeholder enhanced-job-thumbnail ${thumbnailClass}">Processing...</div>`;
        } else if (job.status === 'failed') {
            thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #f8d7da; color: #721c24; display: flex; align-items: center; justify-content: center; font-weight: bold;">Failed</div>`;
        } else if (job.status === 'waiting_for_children') {
            thumbnailHTML = `<div class="content-placeholder enhanced-job-thumbnail ${thumbnailClass}">Waiting...</div>`;
        } else if (job.status === 'stitching') {
            thumbnailHTML = `<div class="content-placeholder enhanced-job-thumbnail ${thumbnailClass}">Stitching...</div>`;
        } else {
            thumbnailHTML = `<div class="enhanced-job-thumbnail ${thumbnailClass}" style="background: #e9ecef; display: flex; align-items: center; justify-content: center; font-size: 11px; padding: 5px; text-align: center; word-wrap: break-word;">${job.status.replace(/_/g, ' ')}</div>`;
        }
        
        // Generate action buttons
        let actionButtons = '';
        if ((job.status === 'completed' || job.status === 'pending_review' || job.status === 'pending_process') && job.result_data) {
            if (job.job_type.includes('image') || job.job_type === 'frame_extraction' || job.job_type === 'background_removal') {
                actionButtons += `<button class="action-btn" onclick="console.log('🎬 Animate button clicked!', '${job.result_data}', ${job.id}); animateImage('${job.result_data}', ${job.id})" style="background: #007bff; font-size: 11px; padding: 4px 8px;">🎬 Animate</button>`;
                actionButtons += `<button class="action-btn" onclick="removeBg('${job.result_data}', ${job.id})" style="background: #17a2b8; font-size: 11px; padding: 4px 8px;">✨ Remove BG</button>`;
            }
            if (job.job_type === 'image_generation' || job.job_type === 'animation') {
                actionButtons += `<button class="action-btn" onclick="regenerateJob(${job.id})" style="background: #6f42c1; font-size: 11px; padding: 4px 8px;">🔄 Regenerate</button>`;
            }
            if (job.job_type === 'animation' || job.job_type === 'video_stitching' || job.job_type === 'video_upload' || job.job_type === 'uploaded_video_keying') {
                // Show Auto Key only if not already keyed and status is not pending_process
                if (!job.keyed_result_data && job.status !== 'pending_process') {
                    actionButtons += `<button class="action-btn" onclick="autoKeyVideo(${job.id}, '${job.result_data}')" style="background: #9c27b0; font-size: 11px; padding: 4px 8px;">🔮 Auto Key</button>`;
                }
                actionButtons += `<button class="action-btn" onclick="openKeyingInterface(${job.id})" style="background: #28a745; font-size: 11px; padding: 4px 8px;">⚙️ ${job.keyed_result_data ? 'Re-Key' : 'Fine-Tune Key'}</button>`;
                actionButtons += `<button class="action-btn" onclick="openExtractFrameModal('${job.result_data}', ${job.id})" style="background: #17a2b8; font-size: 11px; padding: 4px 8px;">🖼️ Extract Frame</button>`;
            }
        }
        actionButtons += `<button class="action-btn" onclick="deleteJob(${job.id})" style="background: #dc3545; font-size: 11px; padding: 4px 8px;">🗑️ Delete</button>`;
        
            const isSelectable = job.status !== 'processing' && job.status !== 'keying_processing';
            
        return `
            <div class="enhanced-job-item" data-job-type="${job.job_type}">
                <div class="enhanced-job-summary" onclick="toggleJobDetails(this)">
                    ${isSelectable ? `<input type="checkbox" class="job-selection-checkbox selection-checkbox" data-job-id="${job.id}" data-job-type="${job.job_type}" onclick="event.stopPropagation()">` : ''}
                    <div class="job-number-badge">#${job.id}</div>
                    ${thumbnailHTML}
                    <div class="job-info-container">
                        <h4 class="job-title">${job.job_type.replace(/_/g, ' ')}</h4>
                        <div class="job-prompt-box">${
                            // Show analysis result for completed analysis jobs
                            (job.job_type === 'style_analysis' || job.job_type === 'palette_analysis' || job.job_type === 'animation_prompting') && job.status === 'completed' && job.result_data
                                ? job.result_data.substring(0, 150) + (job.result_data.length > 150 ? '...' : '')
                                : (job.prompt || 'No prompt')
                        }</div>
                        <div class="job-status-badges">
                            <span class="status-badge status-${job.status}">${job.status.replace(/_/g, ' ')}</span>
                        </div>
                    </div>
                </div>
                <div class="job-details" style="display: none; padding: 15px; border-top: 1px solid #e9ecef;">
                    <div class="enhanced-job-actions">
                        ${actionButtons}
                    </div>
                    <div class="enhanced-job-content">
                        <div class="enhanced-job-media">
                            ${job.job_type === 'style_analysis' || job.job_type === 'palette_analysis' || job.job_type === 'animation_prompting' ? 
                                // For analysis jobs, show input image and analysis result
                                (() => {
                                    let html = '';
                                    let inputData = {};
                                    let imagePath = '';
                                    
                                    // Parse input data safely
                                    try {
                                        inputData = JSON.parse(job.input_data || '{}');
                                        imagePath = inputData.image_path || '';
                                    } catch (e) {
                                        console.error('Error parsing input_data for job', job.id, e);
                                    }
                                    
                                    // Always show the layout if we have an image or result
                                    if (imagePath || job.result_data) {
                                        html += `<div style="display: flex; gap: 15px; align-items: flex-start;">`;
                                        
                                        // Small image column with job info below (if we have an image)
                                        if (imagePath) {
                                            html += `<div style="flex: 0 0 150px;">
                                                <img src="/${imagePath}" style="width: 100%; border-radius: 8px;" class="clickable-image" alt="Analysis Input" onclick="event.stopPropagation(); openImageModal('/${imagePath}')">
                                                <div style="text-align: center; font-size: 11px; color: #666; margin-top: 5px;">Input Image</div>
                                                <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 11px;">
                                                    <div style="margin-bottom: 4px;"><strong>Created:</strong><br>${new Date(job.created_at).toLocaleString()}</div>
                                                    <div><strong>Status:</strong><br><span style="color: #28a745;">${job.status.replace(/_/g, ' ')}</span></div>
                                                </div>
                                            </div>`;
                                        }
                                        
                                        // Result column (takes remaining space)
                                        html += `<div style="flex: 1; min-width: 0;">`;
                                        
                                        if (job.result_data && job.status === 'completed') {
                                            // Show the analysis result
                                            html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #007bff; margin-bottom: 15px;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                                    <h4 style="margin: 0; color: #007bff;">Analysis Result:</h4>
                                                    <button onclick="useAnalysisResult('${job.id}')" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">📋 Use This</button>
                                                </div>
                                                <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap;">${job.result_data}</div>
                                            </div>`;
                                        } else if (job.status === 'processing') {
                                            html += `<div style="background: #fff3cd; padding: 20px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                                                <h4 style="margin: 0; color: #856404;">Processing...</h4>
                                                <p style="margin: 10px 0 0 0; color: #856404;">Analysis in progress, please wait.</p>
                                            </div>`;
                                        } else if (job.status === 'failed') {
                                            html += `<div style="background: #f8d7da; padding: 20px; border-radius: 8px; border-left: 4px solid #dc3545; margin-bottom: 15px;">
                                                <h4 style="margin: 0; color: #721c24;">Analysis Failed</h4>
                                                <p style="margin: 10px 0 0 0; color: #721c24;">${job.error_message || 'Unknown error occurred'}</p>
                                            </div>`;
                                        } else {
                                            html += `<div style="background: #e2e3e5; padding: 20px; border-radius: 8px; border-left: 4px solid #6c757d; margin-bottom: 15px;">
                                                <h4 style="margin: 0; color: #495057;">No Result Available</h4>
                                                <p style="margin: 10px 0 0 0; color: #495057;">Status: ${job.status}</p>
                                            </div>`;
                                        }
                                        
                                        html += `</div></div>`; // Close result column and flex container
                                        
                                        // System prompt in separate box below (full width) - only if we have a result
                                        if (job.result_data && job.status === 'completed') {
                                            let systemPromptUsed = 'Default prompt';
                                            try {
                                                systemPromptUsed = inputData.system_prompt || 'Default prompt';
                                                if (systemPromptUsed === 'Default prompt') {
                                                    systemPromptUsed = 'This job was created with the default system prompt. Newer analysis jobs will show the detailed prompt used.';
                                                }
                                            } catch (e) {
                                                systemPromptUsed = 'Error parsing system prompt data';
                                            }
                                            
                                            html += `<div style="margin-top: 15px;">
                                                <div style="background: #ffffff; padding: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                                                    <h5 style="margin: 0 0 10px 0; color: #6c757d; font-size: 13px;">System Prompt Used:</h5>
                                                    <div style="background: #f8f9fa; padding: 12px; border-radius: 4px; font-size: 12px; line-height: 1.4; color: #495057; max-height: 150px; overflow-y: auto;">${systemPromptUsed}</div>
                                                </div>
                                            </div>`;
                                        }
                                    }
                                    return html;
                                })() :
                                // For other jobs, show result media
                                (job.result_data && (job.status === 'completed' || job.status === 'pending_review' || job.status === 'pending_process') ? 
                                    (job.job_type === 'animation' || job.job_type === 'video_stitching' || job.job_type === 'video_upload' || job.job_type === 'uploaded_video_keying' || job.result_data.match(/\.(mp4|webm|mov)$/i) ?
                                        (() => {
                                            let html = '';
                                            const cacheBuster = '?t=' + Date.now();
                                            // If keyed version exists, show both videos side-by-side
                                            if (job.keyed_result_data) {
                                                const origPath = job.result_data.startsWith('/') ? job.result_data : '/' + job.result_data;
                                                const keyedPath = job.keyed_result_data.startsWith('/') ? job.keyed_result_data : '/' + job.keyed_result_data;
                                                html = `<div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                                    <div style="flex: 1; min-width: 250px;">
                                                        <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #6c757d;">Original:</div>
                                                        <video src="${origPath}${cacheBuster}" style="width: 100%; border-radius: 8px;" playsinline muted loop autoplay controls></video>
                                                        <a href="${origPath}" download class="action-btn" style="background: #007bff; color: white; margin-top: 8px; padding: 6px 12px; border-radius: 4px; text-decoration: none; display: inline-block; font-size: 12px;">⬇️ Download Original</a>
                                                    </div>
                                                    <div style="flex: 1; min-width: 250px;">
                                                        <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #28a745;">Keyed (Background Removed):</div>
                                                        <video src="${keyedPath}${cacheBuster}" style="width: 100%; border-radius: 8px; background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\"><rect width=\"10\" height=\"10\" fill=\"%23ccc\"/><rect x=\"10\" y=\"10\" width=\"10\" height=\"10\" fill=\"%23ccc\"/><rect x=\"10\" width=\"10\" height=\"10\" fill=\"%23fff\"/><rect y=\"10\" width=\"10\" height=\"10\" fill=\"%23fff\"/></svg>'); background-size: 20px 20px;" playsinline muted loop autoplay controls></video>
                                                        <a href="${keyedPath}" download class="action-btn" style="background: #28a745; color: white; margin-top: 8px; padding: 6px 12px; border-radius: 4px; text-decoration: none; display: inline-block; font-size: 12px;">⬇️ Download Keyed</a>
                                                    </div>
                                                </div>`;
                                            } else {
                                                const videoPath = job.result_data.startsWith('/') ? job.result_data : '/' + job.result_data;
                                                html = `<video src="${videoPath}${cacheBuster}" style="max-width: 500px; width: 100%; border-radius: 8px;" playsinline muted loop autoplay controls></video>`;
                                            }
                                            return html;
                                        })() :
                                        `<img src="/${job.result_data}" style="max-width: 500px; width: 100%; border-radius: 8px;" class="clickable-image" alt="Result" onclick="event.stopPropagation(); openImageModal('/${job.result_data}')">`
                                    ) : ''
                                )
                            }
                        </div>
                        <div class="enhanced-job-text">
                            ${job.job_type === 'style_analysis' || job.job_type === 'palette_analysis' || job.job_type === 'animation_prompting' ? 
                                // For analysis jobs, job info is shown in left column with image
                                '' :
                                // For other jobs, show regular prompt and info
                                `<label style="font-weight: 600; margin-bottom: 8px; display: block;">Prompt:</label>
                                <div style="position: relative;">
                                    <textarea class="job-prompt-box" readonly id="job-prompt-${job.id}">${job.prompt || 'No prompt available'}</textarea>
                                    <button class="copy-btn" onclick="copyJobPrompt('job-prompt-${job.id}')" title="Copy prompt" style="background: none; border: none; color: #666; font-size: 16px; cursor: pointer; padding: 4px;">⎘</button>
                                </div>
                                <div style="margin-top: 15px; font-size: 12px; color: #666;">
                                    <p><strong>Created:</strong> ${new Date(job.created_at).toLocaleString()}</p>
                                    <p><strong>Status:</strong> ${job.status.replace(/_/g, ' ')}</p>
                                    ${job.error_message ? `<p><strong>Error:</strong> ${job.error_message}</p>` : ''}
                                    ${job.result_data ? `<p><strong>Output:</strong> ${job.result_data}</p>` : ''}
                                    ${job.keyed_result_data ? `<p><strong>Keyed Output:</strong> ${job.keyed_result_data}</p>` : ''}
                                </div>`
                            }
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function toggleJobDetails(element) {
        const details = element.nextElementSibling;
        const jobItem = element.closest('.enhanced-job-item');
        const isVisible = details.style.display !== 'none';
        
        details.style.display = isVisible ? 'none' : 'block';
        
        // If opening details, play all videos in the expanded section
        if (!isVisible) {
            setTimeout(() => {
                const videos = details.querySelectorAll('video');
                videos.forEach(video => {
                    video.loop = true;
                    video.muted = true;
                    video.play().catch(err => console.log('Video autoplay blocked:', err));
                });
            }, 100);
        }
        
        // Update thumbnail size and job state
        const thumbnail = element.querySelector('.enhanced-job-thumbnail');
        if (thumbnail) {
            thumbnail.classList.toggle('enhanced-job-details-expanded', !isVisible);
        }
        
        // Add data attribute for better CSS targeting
        if (jobItem) {
            jobItem.setAttribute('data-expanded', !isVisible);
        }
        
        // Smart auto-refresh control - pause when opening, resume when all closed
        updateAutoRefreshBasedOnOpenJobs();
    }
    
    function updateAutoRefreshBasedOnOpenJobs() {
        // Count open job details
        const openJobDetails = document.querySelectorAll('.enhanced-job-item[data-expanded="true"]');
        const selectedJobs = document.querySelectorAll('.selection-checkbox:checked');
        
        const hasOpenJobs = openJobDetails.length > 0;
        const hasSelections = selectedJobs.length > 0;
        
        // Debug logging (can be removed in production)
        if (window.DEBUG_MODE) {
            console.log('🔄 Auto-refresh check:', {
                openJobs: openJobDetails.length,
                selectedJobs: selectedJobs.length,
                shouldPause: hasOpenJobs || hasSelections,
                autoRefreshActive: !!window.autoRefreshInterval
            });
        }
        
        if (hasOpenJobs || hasSelections) {
            if (window.autoRefreshInterval) {
                console.log('🔄 Pausing auto-refresh (jobs open or selected)');
                pauseAutoRefresh();
            }
                } else {
            if (!window.autoRefreshInterval) {
                console.log('🔄 Resuming auto-refresh (no open jobs, no selections)');
                startAutoRefresh();
            }
        }
    }
    
    // Action functions for enhanced job rendering - Make globally accessible
    window.animateImage = function(imagePath, parentJobId) {
        console.log('🎬 Animating image:', imagePath, 'Parent Job ID:', parentJobId);
        
        try {
            // Check if required elements exist
            const requiredElements = ['animation_image_url', 'animation_parent_job_id', 'animation-preview', 'start-frame-display', 'end-frame-controls', 'animation-form-container', 'animation-section'];
            for (let elementId of requiredElements) {
                if (!document.getElementById(elementId)) {
                    console.error(`❌ Required element not found: ${elementId}`);
                    alert(`Error: Animation form element ${elementId} not found. Please refresh the page.`);
                    return;
                }
            }
            
            // Populate animation form with the image
            document.getElementById('animation_image_url').value = imagePath;
            document.getElementById('animation_parent_job_id').value = parentJobId;
            
            // Set up the preview image
            const previewImg = document.getElementById('animation-preview');
            previewImg.src = '/' + imagePath.replace(/^\//, '');
            previewImg.onload = function() {
                console.log('✅ Animation preview image loaded successfully');
            };
            previewImg.onerror = function() {
                console.error('❌ Failed to load preview image:', imagePath);
            };
            
            // Show the animation form sections
            document.getElementById('start-frame-display').style.display = 'block';
            const endFrameControls = document.getElementById('end-frame-controls');
            endFrameControls.style.display = 'block';
            console.log('✅ End frame controls shown:', endFrameControls.style.display);
            document.getElementById('animation-form-container').style.display = 'block';
            
            // Open and scroll to animation section
            const animationSection = document.getElementById('animation-section');
            animationSection.setAttribute('open', '');
            animationSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Show success message (silently via notification)
            setTimeout(() => {
                showUserFriendlyError('Image loaded in Animation Creator!', null, 'success');
            }, 500);
            
            console.log('✅ Animation form populated successfully');
            
        } catch (error) {
            console.error('❌ Error populating animation form:', error);
            showUserFriendlyError('Error loading image in animation tool: ' + error.message, error, 'error');
        }
    };
    
    window.removeBg = function(imagePath, parentJobId) {
        const formData = new FormData();
        formData.append('image_url', '/' + imagePath);
        formData.append('parent_job_id', parentJobId);
        
        showPlaceholder('Removing background...');
        
        fetch('/remove-background', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshJobLog();
            } else {
                showUserFriendlyError('Background removal failed: ' + data.error, null, 'error');
            }
        })
        .catch(error => {
            console.error('Remove BG error:', error);
            showUserFriendlyError('Background removal error: ' + error.message, error, 'error');
        });
    };
    
    window.regenerateJob = function(jobId) {
        if (confirm('Regenerate this job with the same parameters?')) {
            // This would need to fetch the job details and resubmit
            showPlaceholder('Regenerating job...');
            
            fetch(`/api/jobs/${jobId}/regenerate`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    refreshJobLog();
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Regenerate error:', error);
                alert('Error: ' + error.message);
            });
        }
    };
    
    window.deleteJob = function(jobId) {
        if (confirm('Delete this job permanently?')) {
            fetch('/api/batch-delete-items', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_ids: [jobId] })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    refreshJobLog();
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                alert('Error: ' + error.message);
            });
        }
    };
    
    window.autoKeyVideo = async function(jobId, videoPath) {
        console.log('🔮 Auto-keying video for job:', jobId);
        
        // First, check if this is an uploaded video that needs background color selection
        try {
            const jobsResponse = await fetch('/api/jobs');
            const jobsData = await jobsResponse.json();
            const jobs = Array.isArray(jobsData) ? jobsData : (jobsData.jobs || []);
            const job = jobs.find(j => j.id === jobId);
            
            if (job && (job.job_type === 'video_upload' || job.job_type === 'uploaded_video_keying')) {
                // For uploaded videos, ask user to select background color
                const bgColor = prompt('What background color should be keyed?\n\nEnter:\n• "green" for green screen\n• "blue" for blue screen', 'green');
                
                if (!bgColor || (bgColor.toLowerCase() !== 'green' && bgColor.toLowerCase() !== 'blue')) {
                    alert('❌ Auto-key cancelled. Please enter "green" or "blue".');
                    return;
                }
                
                // Update the job's input_data with the background color
                try {
                    const inputData = JSON.parse(job.input_data || '{}');
                    inputData.background = bgColor.toLowerCase();
                    
                    // Save updated input_data back to job
                    await fetch(`/api/update-job-input/${jobId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ input_data: inputData })
                    });
                } catch (e) {
                    console.error('Error updating job input data:', e);
                }
            }
            
            // Call the backend to apply auto-key settings
            const response = await fetch(`/auto-key-video/${jobId}`, {
                method: 'POST'
            });
            
            const data = await response.json();
            if (data.success) {
                showUserFriendlyError(data.message, null, 'success');
                refreshJobLog();
            } else {
                showUserFriendlyError('Auto-key error: ' + data.error, null, 'error');
            }
        } catch (error) {
            console.error('Auto-key error:', error);
            showUserFriendlyError('Auto-key error: ' + error.message, error, 'error');
        }
    };
    
    window.openKeyingInterface = function(jobId) {
        console.log('🎬 Opening keying interface for job:', jobId);
        
        // Fetch job details
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                const jobs = Array.isArray(data) ? data : (data.jobs || []);
                const job = jobs.find(j => j.id === jobId);
                
                if (!job || !job.result_data) {
                    showUserFriendlyError('Job not found or has no video result.', null, 'error');
                    return;
                }
                
                console.log('📹 Loading job', jobId, 'with video:', job.result_data);
                
                // Hide empty message and show keying tool
                document.getElementById('keying-tool-empty').style.display = 'none';
                document.getElementById('keying-tool-container').style.display = 'block';
                
                // Set up video and form
                const videoPath = '/' + job.result_data.replace(/^\/+/, '') + '?t=' + Date.now(); // Cache busting
                const videoPreview = document.getElementById('keying-video-preview');
                const imagePreview = document.getElementById('keying-image-preview');
                
                // Clear previous preview
                imagePreview.src = '';
                imagePreview.style.display = 'none';
                videoPreview.style.display = 'block';
                
                // Update video source and force reload
                videoPreview.src = videoPath;
                videoPreview.load(); // Force video reload
                videoPreview.currentTime = 0; // Reset to beginning
                
                // Reset zoom
                currentZoom = 1.0;
                videoPreview.style.transform = 'scale(1)';
                imagePreview.style.transform = 'scale(1)';
                
                document.getElementById('keying-job-id').value = jobId;
                document.getElementById('keying-video-path').value = videoPath;
                
                // Load existing keying settings for this job if they exist
                if (job.keying_settings) {
                    try {
                        const settings = JSON.parse(job.keying_settings);
                        console.log('📋 Loading saved keying settings:', settings);
                        document.getElementById('hue_center').value = settings.hue_center || 60;
                        document.getElementById('hue_tolerance').value = settings.hue_tolerance || 25;
                        document.getElementById('saturation_min').value = settings.saturation_min || 50;
                        document.getElementById('value_min').value = settings.value_min || 50;
                        document.getElementById('erode').value = settings.erode || 0;
                        document.getElementById('dilate').value = settings.dilate || 0;
                        document.getElementById('blur').value = settings.blur || 5;
                        document.getElementById('spill').value = settings.spill || 2;
                        
                        // Update span displays
                        document.getElementById('hue_center_val').textContent = settings.hue_center || 60;
                        document.getElementById('hue_tolerance_val').textContent = settings.hue_tolerance || 25;
                        document.getElementById('saturation_min_val').textContent = settings.saturation_min || 50;
                        document.getElementById('value_min_val').textContent = settings.value_min || 50;
                        document.getElementById('erode_val').textContent = settings.erode || 0;
                        document.getElementById('dilate_val').textContent = settings.dilate || 0;
                        document.getElementById('blur_val').textContent = settings.blur || 5;
                        document.getElementById('spill_val').textContent = settings.spill || 2;
                    } catch (e) {
                        console.error('Error parsing keying settings:', e);
                    }
                } else {
                    console.log('🔧 No saved settings, using defaults');
                }
                
                // Open and scroll to keying section
                const keyingSection = document.getElementById('keying-section');
                keyingSection.setAttribute('open', '');
                keyingSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Initialize keying controls if not already done
                initializeKeyingControls();
                
                console.log('✅ Keying interface loaded for job', jobId, 'with video:', videoPath);
            })
            .catch(error => {
                console.error('Error loading job for keying:', error);
                alert('Error loading video for keying.');
            });
    };
    
    let keyingControlsInitialized = false;
    let colorSamplerEnabled = false;
    let currentZoom = 1.0;
    
    function initializeKeyingControls() {
        if (keyingControlsInitialized) return;
        keyingControlsInitialized = true;
        
        const videoPreview = document.getElementById('keying-video-preview');
        const imagePreview = document.getElementById('keying-image-preview');
        const previewBtn = document.getElementById('keying-preview-btn');
        const saveBtn = document.getElementById('keying-save-btn');
        const prevFrameBtn = document.getElementById('prev-frame-btn');
        const nextFrameBtn = document.getElementById('next-frame-btn');
        const videoContainer = document.getElementById('keying-video-container');
        const toggleSamplerBtn = document.getElementById('toggle-sampler-btn');
        const applySampledColorBtn = document.getElementById('apply-sampled-color-btn');
        const colorIndicator = document.getElementById('color-sample-indicator');
        const sampledColorDisplay = document.getElementById('sampled-color-display');
        
        // New button references
        const resetPreviewBtn = document.getElementById('reset-preview-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');
        
        const FPS = 30;
        const FRAME_DURATION = 1 / FPS;
        
        // Color Sampler functionality
        let sampledHSV = { h: 0, s: 0, v: 0 };
        
        toggleSamplerBtn.addEventListener('click', () => {
            colorSamplerEnabled = !colorSamplerEnabled;
            if (colorSamplerEnabled) {
                toggleSamplerBtn.textContent = 'Disable';
                toggleSamplerBtn.style.background = '#dc3545';
                videoContainer.style.cursor = 'crosshair';
                videoPreview.pause();
                alert('Color Sampler enabled! Click on the video to sample a color.');
            } else {
                toggleSamplerBtn.textContent = 'Enable';
                toggleSamplerBtn.style.background = '#2196f3';
                videoContainer.style.cursor = 'default';
                colorIndicator.style.display = 'none';
            }
        });
        
        videoContainer.addEventListener('click', (e) => {
            if (!colorSamplerEnabled) return;
            e.preventDefault();
            
            const rect = videoPreview.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Show indicator at click position
            colorIndicator.style.left = e.clientX - videoContainer.getBoundingClientRect().left - 15 + 'px';
            colorIndicator.style.top = e.clientY - videoContainer.getBoundingClientRect().top - 15 + 'px';
            colorIndicator.style.display = 'block';
            
            // Sample color from video at this point
            sampleColorFromVideo(videoPreview, x, y);
        });
        
        function sampleColorFromVideo(video, x, y) {
            // Create a temporary canvas to sample the pixel
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Draw the video frame
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Calculate the actual pixel position in the video
            const scaleX = video.videoWidth / video.offsetWidth;
            const scaleY = video.videoHeight / video.offsetHeight;
            const pixelX = Math.floor(x * scaleX);
            const pixelY = Math.floor(y * scaleY);
            
            // Get pixel data
            const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
            const [r, g, b] = imageData.data;
            
            // Convert RGB to HSV
            const hsv = rgbToHsv(r, g, b);
            sampledHSV = hsv;
            
            // Display the sampled color
            document.getElementById('sampled-color-box').style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            document.getElementById('sampled-hue').textContent = Math.round(hsv.h);
            document.getElementById('sampled-sat').textContent = Math.round(hsv.s);
            document.getElementById('sampled-val').textContent = Math.round(hsv.v);
            sampledColorDisplay.style.display = 'block';
            
            console.log('Sampled color:', { r, g, b }, 'HSV:', hsv);
        }
        
        function rgbToHsv(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            let h = 0;
            if (diff !== 0) {
                if (max === r) {
                    h = 60 * (((g - b) / diff) % 6);
                } else if (max === g) {
                    h = 60 * (((b - r) / diff) + 2);
                } else {
                    h = 60 * (((r - g) / diff) + 4);
                }
            }
            if (h < 0) h += 360;
            
            const s = max === 0 ? 0 : (diff / max) * 255;
            const v = max * 255;
            
            // Convert hue to OpenCV range (0-180)
            h = h / 2;
            
            return { h, s, v };
        }
        
        applySampledColorBtn.addEventListener('click', () => {
            // Apply sampled values to sliders
            // Hue: use directly
            document.getElementById('hue_center').value = Math.round(sampledHSV.h);
            document.getElementById('hue_center_val').textContent = Math.round(sampledHSV.h);
            
            // Saturation & Value: invert them (255 - sampled)
            // If sampled S is high (255), we want saturation_min to be low (0)
            // This is because saturation_min is a threshold - we key pixels ABOVE this threshold
            const invertedS = Math.max(0, 255 - Math.round(sampledHSV.s));
            const invertedV = Math.max(0, 255 - Math.round(sampledHSV.v));
            
            document.getElementById('saturation_min').value = invertedS;
            document.getElementById('saturation_min_val').textContent = invertedS;
            
            document.getElementById('value_min').value = invertedV;
            document.getElementById('value_min_val').textContent = invertedV;
            
            console.log(`🎨 Applied inverted color: H=${Math.round(sampledHSV.h)}, S=${invertedS} (from ${Math.round(sampledHSV.s)}), V=${invertedV} (from ${Math.round(sampledHSV.v)})`);
            showUserFriendlyError('Color values applied to sliders!', null, 'success');
        });
        
        // Frame navigation
        function seekVideo(direction) {
            videoPreview.pause();
            let newTime = videoPreview.currentTime + (FRAME_DURATION * direction);
            videoPreview.currentTime = Math.max(0, Math.min(videoPreview.duration, newTime));
        }
        
        prevFrameBtn.addEventListener('click', () => seekVideo(-1));
        nextFrameBtn.addEventListener('click', () => seekVideo(1));
        
        // Slider value updates
        const sliders = document.querySelectorAll('#keying-form input[type="range"]');
        sliders.forEach(slider => {
            const display = document.getElementById(`${slider.id}_val`);
            if (display) {
                slider.addEventListener('input', () => { display.textContent = slider.value; });
            }
        });
        
        // Preview frame
        previewBtn.addEventListener('click', async () => {
            previewBtn.textContent = 'Processing...';
            previewBtn.disabled = true;
            
            const formData = new FormData();
            formData.append('video_path', document.getElementById('keying-video-path').value);
            formData.append('frame_time', videoPreview.currentTime);
            sliders.forEach(s => formData.append(s.name, s.value));
            
            try {
                const response = await fetch('/api/preview-frame', { method: 'POST', body: formData });
                if (!response.ok) throw new Error(`Preview failed (${response.status})`);
                
                const blob = await response.blob();
                if (imagePreview.src) URL.revokeObjectURL(imagePreview.src);
                imagePreview.src = URL.createObjectURL(blob);
                
                videoPreview.style.display = 'none';
                imagePreview.style.display = 'block';
            } catch (error) {
                console.error('Preview error:', error);
                alert('Could not generate preview. Please try again.');
            } finally {
                previewBtn.textContent = '🔍 Preview Frame';
                previewBtn.disabled = false;
            }
        });
        
        // Click preview to return to video
        imagePreview.addEventListener('click', () => {
            imagePreview.style.display = 'none';
            videoPreview.style.display = 'block';
        });
        
        // Reset Preview button - return to video view
        resetPreviewBtn.addEventListener('click', () => {
            console.log('🔄 Resetting preview to video');
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            videoPreview.style.display = 'block';
            videoPreview.currentTime = 0;
            
            // Disable color sampler
            if (colorSamplerEnabled) {
                colorSamplerEnabled = false;
                toggleSamplerBtn.textContent = 'Enable';
                toggleSamplerBtn.style.background = '#2196f3';
                videoContainer.style.cursor = 'crosshair';
                colorIndicator.style.display = 'none';
            }
        });
        
        // Zoom controls
        function applyZoom() {
            const activeElement = videoPreview.style.display !== 'none' ? videoPreview : imagePreview;
            activeElement.style.transform = `scale(${currentZoom})`;
            console.log('🔍 Zoom level:', currentZoom);
        }
        
        zoomInBtn.addEventListener('click', () => {
            currentZoom = Math.min(currentZoom + 0.25, 4.0); // Max 4x zoom
            applyZoom();
        });
        
        zoomOutBtn.addEventListener('click', () => {
            currentZoom = Math.max(currentZoom - 0.25, 0.5); // Min 0.5x zoom
            applyZoom();
        });
        
        zoomResetBtn.addEventListener('click', () => {
            currentZoom = 1.0;
            applyZoom();
        });
        
        // Save and process
        saveBtn.addEventListener('click', async () => {
            const jobId = document.getElementById('keying-job-id').value;
            if (!jobId) {
                alert('No job loaded');
                return;
            }
            
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            const formData = new FormData(document.getElementById('keying-form'));
            
            try {
                const response = await fetch(`/save-keying-settings/${jobId}`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    alert('✅ Keying settings saved! Processing video with chroma key...');
                    // Refresh job log
                    if (window.refreshJobLog) {
                        window.refreshJobLog();
                    }
                } else {
                    alert('Error: ' + (result.error || 'Failed to save settings'));
                }
            } catch (error) {
                console.error('Save error:', error);
                alert('Error saving keying settings.');
            } finally {
                saveBtn.textContent = '💾 Save & Process';
                saveBtn.disabled = false;
            }
        });
        
        // Background checker controls
        const root = document.documentElement;
        const checkerColor1 = document.getElementById('checkerColor1');
        const checkerColor2 = document.getElementById('checkerColor2');
        const checkerSize = document.getElementById('checkerSize');
        
        checkerColor1.addEventListener('input', () => {
            document.querySelector('#keying-section .video-container').style.setProperty('background-image', 
                `linear-gradient(45deg, ${checkerColor1.value} 25%, transparent 25%), linear-gradient(-45deg, ${checkerColor1.value} 25%, transparent 25%), linear-gradient(45deg, transparent 75%, ${checkerColor1.value} 75%), linear-gradient(-45deg, transparent 75%, ${checkerColor1.value} 75%)`);
        });
        checkerColor2.addEventListener('input', () => {
            document.querySelector('#keying-section .video-container').style.backgroundColor = checkerColor2.value;
        });
        checkerSize.addEventListener('input', () => {
            const size = `${checkerSize.value}px`;
            document.querySelector('#keying-section .video-container').style.backgroundSize = `${size} ${size}`;
        });
    }
    
    // Enhanced animation idea generator with image analysis using GPT Vision
    window.getAnimationIdea = function() {
        console.log('💡 Getting animation idea from GPT Vision...');
        
        const promptTextarea = document.getElementById('animation_prompt');
        if (!promptTextarea) {
            console.error('❌ Animation prompt textarea not found');
            alert('Error: Could not find animation prompt field.');
            return;
        }
        
        // Get the current image URL from the animation preview
        const animationPreview = document.getElementById('animation-preview');
        const imageUrlInput = document.getElementById('animation_image_url');
        
        if (!animationPreview || !animationPreview.src || !imageUrlInput || !imageUrlInput.value) {
            alert('Please load an image first before getting animation ideas.');
            return;
        }
        
        const imageUrl = imageUrlInput.value;
        console.log('📸 Sending image to GPT Vision:', imageUrl);
        
        // Show loading state
        const originalButtonText = document.getElementById('get-animation-idea-btn')?.textContent || '💡 Get Idea';
        const getIdeaBtn = document.getElementById('get-animation-idea-btn');
        if (getIdeaBtn) {
            getIdeaBtn.textContent = '⏳ Analyzing...';
            getIdeaBtn.disabled = true;
        }
        
        // Call the backend API with GPT Vision
        const formData = new FormData();
        formData.append('image_url', imageUrl);
        
        fetch('/get-animation-idea', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.job_id) {
                console.log('✅ Animation idea job queued:', data.job_id);
                
                // Poll for the result and auto-paste when complete
                pollForAnimationIdea(data.job_id, promptTextarea, getIdeaBtn, originalButtonText);
                
                // Refresh the job log to show the new job
                if (window.refreshJobLog) {
                    window.refreshJobLog();
                }
            } else {
                alert('Error: ' + (data.error || 'Failed to queue animation idea job'));
                if (getIdeaBtn) {
                    getIdeaBtn.textContent = originalButtonText;
                    getIdeaBtn.disabled = false;
                }
            }
        })
        .catch(error => {
            console.error('❌ Error getting animation idea:', error);
            alert('Error connecting to server: ' + error.message);
            if (getIdeaBtn) {
                getIdeaBtn.textContent = originalButtonText;
                getIdeaBtn.disabled = false;
            }
        });
    };
    
    // Poll for animation idea result and auto-paste when complete
    function pollForAnimationIdea(jobId, promptTextarea, button, originalButtonText) {
        let pollCount = 0;
        const maxPolls = 60; // Poll for up to 60 seconds
        
        const pollInterval = setInterval(() => {
            pollCount++;
            
            fetch(`/api/job-status/${jobId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'completed' && data.result_data) {
                        clearInterval(pollInterval);
                        
                        // Auto-paste the result
                        promptTextarea.value = data.result_data;
                        
                        // Update button state
                        if (button) {
                            button.textContent = '✅ Idea Ready!';
                            button.style.background = '#28a745';
        setTimeout(() => {
                                button.textContent = originalButtonText;
                                button.style.background = '';
                                button.disabled = false;
                            }, 3000);
                        }
                        
                        // Show success message
                        console.log('✅ Animation idea automatically pasted!');
                        
                        // Refresh job log to show completed status
                        if (window.refreshJobLog) {
                            window.refreshJobLog();
                        }
                    } else if (data.status === 'failed') {
                        clearInterval(pollInterval);
                        alert('Animation idea analysis failed: ' + (data.error_message || 'Unknown error'));
                        if (button) {
                            button.textContent = originalButtonText;
                            button.disabled = false;
                        }
                    } else if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        alert('Animation idea is taking longer than expected. Check the job log for results.');
                        if (button) {
                            button.textContent = originalButtonText;
                            button.disabled = false;
                        }
                    }
                })
                .catch(error => {
                    console.error('Error polling job status:', error);
                    if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        if (button) {
                            button.textContent = originalButtonText;
                            button.disabled = false;
                        }
                    }
                });
        }, 1000); // Poll every second
    }
    
    // Library and Job Selection Modal Functions
    window.openLibraryModal = function(targetType) {
        console.log('📚 Opening library modal for:', targetType);
        
        // Fetch library items
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                // Handle both array and object response formats
                const jobs = Array.isArray(data) ? data : (data.jobs || []);
                const completedImageJobs = jobs.filter(job => 
                    job.status === 'completed' && 
                    (job.job_type.includes('image') || job.job_type === 'frame_extraction' || job.job_type === 'background_removal') &&
                    job.result_data
                ).slice(0, 50); // Limit to 50 most recent images
                
                if (completedImageJobs.length === 0) {
                    alert('No images found in library. Generate some images first!');
                    return;
                }
                
                showImageSelectionModal(completedImageJobs, 'Select Image from Library', (selectedJob) => {
                    if (targetType === 'animation-end') {
                        setEndFrameImage(selectedJob.result_data, selectedJob.id);
                    }
                });
            })
            .catch(error => {
                console.error('Error loading library:', error);
                alert('Error loading library images.');
            });
    };
    
    window.openJobSelectModal = function(targetType) {
        console.log('📋 Opening job selection modal for:', targetType);
        
        // Fetch recent completed jobs
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                // Handle both array and object response formats
                const jobs = Array.isArray(data) ? data : (data.jobs || []);
                const recentImageJobs = jobs
                    .filter(job => 
                        job.status === 'completed' && 
                        (job.job_type.includes('image') || job.job_type === 'frame_extraction' || job.job_type === 'background_removal') &&
                        job.result_data
                    )
                    .slice(0, 50); // Show last 50 completed image jobs
                
                if (recentImageJobs.length === 0) {
                    alert('No recent image jobs found.');
                    return;
                }
                
                showImageSelectionModal(recentImageJobs, 'Select from Recent Jobs', (selectedJob) => {
                    if (targetType === 'animation-end') {
                        setEndFrameImage(selectedJob.result_data, selectedJob.id);
                    }
                });
            })
            .catch(error => {
                console.error('Error loading jobs:', error);
                alert('Error loading recent jobs.');
            });
    };
    
    function showImageSelectionModal(jobs, title, onSelect) {
        // Create modal HTML with 4x4 grid
        const modalHTML = `
            <div id="imageSelectionModal" style="
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.8); z-index: 1000; display: flex; 
                align-items: center; justify-content: center; padding: 20px;
            ">
                <div style="
                    background: white; border-radius: 12px; width: 1000px; height: 700px; 
                    display: flex; flex-direction: column;
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 2px solid #e9ecef; flex-shrink: 0;">
                        <h3 style="margin: 0;">${title}</h3>
                        <button onclick="closeImageSelectionModal()" style="
                            background: #dc3545; color: white; border: none; border-radius: 4px; 
                            padding: 10px 20px; cursor: pointer; font-size: 14px; font-weight: bold;
                        ">✕ Close</button>
                    </div>
                    <div id="imageGrid" style="
                        display: grid; 
                        grid-template-columns: repeat(4, 1fr); 
                        gap: 15px; 
                        padding: 20px; 
                        overflow-y: auto; 
                        flex: 1;
                    ">
                        ${jobs.map(job => `
                            <div style="
                                border: 2px solid #dee2e6; 
                                border-radius: 8px; 
                                overflow: hidden; 
                                cursor: pointer; 
                                transition: all 0.2s ease; 
                                background: white;
                                display: flex;
                                flex-direction: column;
                                height: 200px;
                            " onmouseover="this.style.borderColor='#007bff'; this.style.transform='scale(1.02)';" 
                               onmouseout="this.style.borderColor='#dee2e6'; this.style.transform='scale(1)';"
                               onclick="selectImageFromModal(${job.id}, '${job.result_data}')">
                                <div style="
                                    flex: 1;
                                    display: flex; 
                                    align-items: center; 
                                    justify-content: center; 
                                    background: #f8f9fa; 
                                    padding: 8px;
                                    overflow: hidden;
                                ">
                                <img src="/${job.result_data.replace(/^\/+/, '')}" alt="Job ${job.id}" style="
                                        max-width: 100%; 
                                        max-height: 100%; 
                                        object-fit: contain;
                                        display: block;
                                    ">
                                </div>
                                <div style="
                                    padding: 8px; 
                                    font-size: 11px; 
                                    background: white; 
                                    border-top: 1px solid #e9ecef;
                                    text-align: center;
                                    flex-shrink: 0;
                                ">
                                    <strong>Job #${job.id}</strong><br>
                                    <span style="color: #6c757d;">${job.job_type.replace(/_/g, ' ')}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to page
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Store the callback function globally for selectImageFromModal to use
        window.currentModalCallback = onSelect;
    }
    
    window.closeImageSelectionModal = function() {
        const modal = document.getElementById('imageSelectionModal');
        if (modal) {
            modal.remove();
        }
        window.currentModalCallback = null;
    };
    
    window.selectImageFromModal = function(jobId, imagePath) {
        if (window.currentModalCallback) {
            window.currentModalCallback({ id: jobId, result_data: imagePath });
        }
        closeImageSelectionModal();
    };
    
    function setEndFrameImage(imagePath, jobId) {
        console.log('🖼️ Setting end frame:', imagePath, jobId);
        
        // Set the hidden input value - try both possible IDs
        const endImageInput = document.getElementById('end_image_url_input') || document.getElementById('animation_end_image_url');
        if (endImageInput) {
            endImageInput.value = imagePath;
        }
        
        // Enable boomerang automation flag
        const boomerangFlag = document.getElementById('boomerang_automation_flag');
        if (boomerangFlag) {
            boomerangFlag.value = 'true';
            console.log('✅ Boomerang automation enabled for ABA loop');
        }
        
        // Show the end frame preview - try both possible IDs
        const endFramePreview = document.getElementById('end-frame-preview') || document.getElementById('animation-end-preview');
        const endFrameDisplay = document.getElementById('end-frame-display');
        
        if (endFramePreview) {
            // Ensure the path starts with / and doesn't have double slashes
            const cleanPath = '/' + imagePath.replace(/^\/+/, '');
            endFramePreview.src = cleanPath;
            if (endFrameDisplay) {
                endFrameDisplay.style.display = 'block';
            }
        }
        
        alert('✅ End frame image selected! This will create an ABA-style loop animation.\n\nThe system will:\n1. Animate A→B (start to end)\n2. Animate B→A (end to start)\n3. Stitch them together into a seamless loop');
    }
    
    // Group action functions
    window.animateGroupImages = function(jobIds) {
        const selectedIds = getSelectedImagesFromGroup();
        if (selectedIds.length === 0) {
            alert('Please select images to animate by checking their boxes.');
            return;
        }
        
        // Get the first selected image data for animation
        const firstSelectedId = selectedIds[0];
        
        // Find the job data for the first selected image
        fetch('/api/jobs')
            .then(response => response.json())
            .then(data => {
                // Handle both array and object response formats
                const jobs = Array.isArray(data) ? data : (data.jobs || []);
                const selectedJob = jobs.find(job => job.id === firstSelectedId);
                if (selectedJob && selectedJob.result_data) {
                    // Use the existing animateImage function for the first selected image
                    animateImage(selectedJob.result_data, selectedJob.id);
                    
                    if (selectedIds.length > 1) {
                        alert(`Animation tool loaded with first selected image. ${selectedIds.length - 1} other images selected for batch processing.`);
                    }
                    } else {
                    alert('Could not find image data for selected item.');
                }
            })
            .catch(error => {
                console.error('Error fetching job data:', error);
                alert('Error loading selected image for animation.');
            });
    };
    
    function removeBgGroup(jobIds) {
        const selectedIds = getSelectedImagesFromGroup();
        if (selectedIds.length === 0) {
            alert('Please select images for background removal by checking their boxes.');
            return;
        }
        showPlaceholder(`Removing backgrounds from ${selectedIds.length} images...`);
            
            // Fetch job data to get image paths
            fetch('/api/jobs')
                .then(response => response.json())
                .then(data => {
                    const jobs = Array.isArray(data) ? data : (data.jobs || []);
                    
                    // Process each selected image with its actual path
                    selectedIds.forEach(jobId => {
                        const job = jobs.find(j => j.id === jobId);
                        if (job && job.result_data) {
                            removeBg(job.result_data, jobId);
                        } else {
                            console.error('Could not find result_data for job', jobId);
                        }
                    });
                })
                .catch(error => {
                    console.error('Error fetching job data for background removal:', error);
                    alert('Error: Could not fetch image data');
                });
        }
    }
    
    function regenerateGroup(jobIds) {
        if (confirm(`Regenerate all ${jobIds.length} images in this group?`)) {
            showPlaceholder(`Regenerating ${jobIds.length} images...`);
            jobIds.forEach(jobId => {
                fetch(`/api/jobs/${jobId}/regenerate`, { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (!data.success) console.error('Regenerate failed for job', jobId);
                    });
            });
            setTimeout(() => refreshJobLog(), 1000);
        }
    }
    
    function deleteGroup(jobIds) {
        if (confirm(`Delete all ${jobIds.length} jobs in this group permanently?`)) {
            fetch('/api/batch-delete-items', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ job_ids: jobIds })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    refreshJobLog();
                    } else {
                    alert('Error: ' + data.error);
                }
            });
        }
    }
    
    function getSelectedImagesFromGroup() {
        const selected = Array.from(document.querySelectorAll('.image-checkbox:checked'))
                   .map(cb => parseInt(cb.dataset.jobId))
                   .filter(id => id && !isNaN(id));
        
        console.log('🔍 Selected image IDs from group:', selected);
        return selected;
    }
    
    // Extract Frame functionality
    function handleExtractVideoUpload(input) {
        const file = input.files[0];
        if (!file) return;
        
        const video = document.getElementById('extract-preview-video');
        const container = document.getElementById('extract-preview-container');
        const uploadArea = document.getElementById('extract-upload-area');
        const timeSlider = document.getElementById('extract-frame-time');
        const timeInput = document.getElementById('extract-frame-time-input');
        
        video.src = URL.createObjectURL(file);
        container.style.display = 'block';
        uploadArea.style.display = 'none'; // Hide upload area when video loaded
        
        video.addEventListener('loadedmetadata', function() {
            timeSlider.max = video.duration;
            timeInput.max = video.duration;
            timeSlider.value = 0;
            timeInput.value = 0;
            
            // Update step size for frame-perfect seeking (assuming 30fps)
            const frameTime = 1/30;
            timeSlider.step = frameTime;
            timeInput.step = frameTime;
        });
        
        // Store file for extraction
        window.currentExtractFile = file;
    }
    
    function clearExtractVideo() {
        const video = document.getElementById('extract-preview-video');
        const container = document.getElementById('extract-preview-container');
        const uploadArea = document.getElementById('extract-upload-area');
        const fileInput = document.getElementById('extract-video-upload');
        
        video.src = '';
        container.style.display = 'none';
        uploadArea.style.display = 'block';
        fileInput.value = '';
        
        window.currentExtractFile = null;
        window.currentVideoPath = null;
        window.currentVideoJobId = null;
    }
    
    function stepFrame(stepValue) {
        const video = document.getElementById('extract-preview-video');
        const timeSlider = document.getElementById('extract-frame-time');
        const timeInput = document.getElementById('extract-frame-time-input');
        
        const currentTime = parseFloat(timeSlider.value);
        const newTime = Math.max(0, Math.min(video.duration, currentTime + stepValue));
        
        timeSlider.value = newTime;
        timeInput.value = newTime.toFixed(3);
        video.currentTime = newTime;
    }
    
    function updateExtractPreview() {
        const video = document.getElementById('extract-preview-video');
        const timeSlider = document.getElementById('extract-frame-time');
        const timeInput = document.getElementById('extract-frame-time-input');
        
        const time = parseFloat(timeSlider.value || timeInput.value);
        video.currentTime = time;
        
        // Sync both inputs
        timeSlider.value = time;
        timeInput.value = time;
    }
    
    function extractCurrentFrame() {
        const video = document.getElementById('extract-preview-video');
        const time = parseFloat(document.getElementById('extract-frame-time').value);
        
        if (!video.src) {
            alert('Please upload or select a video first');
            return;
        }
        
        const formData = new FormData();
        
        // Check if we have an uploaded file or a job video path
        if (window.currentExtractFile) {
            // Use uploaded file
            formData.append('video', window.currentExtractFile);
        } else if (window.currentVideoPath) {
            // Use job video path
            formData.append('video_path', window.currentVideoPath);
            if (window.currentVideoJobId) {
                formData.append('parent_job_id', window.currentVideoJobId);
            }
        } else {
            alert('No video source available for extraction');
            return;
        }
        
        formData.append('frame_time', time);
        
        showPlaceholder('Extracting frame...');
        
        fetch('/api/extract-frame', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                refreshJobLog();
                // Don't close the modal - user might want to extract another frame
                alert('Frame extracted successfully!');
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            alert('Error: ' + error.message);
        });
    }
    
    function openExtractFrameModal(videoPath, jobId) {
        // Automatically load the video into the extract frame tool
        const extractSection = document.getElementById('extract-frame-section');
        const video = document.getElementById('extract-preview-video');
        const container = document.getElementById('extract-preview-container');
        const uploadArea = document.getElementById('extract-upload-area');
        const timeSlider = document.getElementById('extract-frame-time');
        const timeInput = document.getElementById('extract-frame-time-input');
        
        // Open the extract section if it's closed
        if (!extractSection.hasAttribute('open')) {
            extractSection.setAttribute('open', '');
        }
        
        // Load the video and hide upload area
        video.src = '/' + videoPath.replace(/^\//, '');
        container.style.display = 'block';
        uploadArea.style.display = 'none';
        
        video.addEventListener('loadedmetadata', function() {
            timeSlider.max = video.duration;
            timeInput.max = video.duration;
            timeSlider.value = 0;
            timeInput.value = 0;
            
            // Update step size for frame-perfect seeking
            const frameTime = 1/30;
            timeSlider.step = frameTime;
            timeInput.step = frameTime;
        });
        
        // Store the job info for potential use
        window.currentVideoJobId = jobId;
        window.currentVideoPath = videoPath;
        window.currentExtractFile = null; // Clear uploaded file
        
        // Scroll to the extract tool
        extractSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        // Show success message
        setTimeout(() => {
            showUserFriendlyError('Video loaded in Extract Frame tool!', null, 'success');
        }, 500);
    }
    
    // Resizable divider functionality
    function initResizable() {
        const divider = document.getElementById('resizer');
        const leftPanel = document.querySelector('.dashboard-panel');
        const rightPanel = document.querySelector('.queue-panel');
        let isResizing = false;
        
        divider.addEventListener('mousedown', function(e) {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = document.querySelector('.split-container').getBoundingClientRect();
            const newLeftWidth = e.clientX - containerRect.left;
            
            // Set minimum and maximum widths - allow user full control
            const minLeftWidth = 280;
            const maxLeftWidth = Math.max(1200, containerRect.width - 200);
            
            if (newLeftWidth >= minLeftWidth && newLeftWidth <= maxLeftWidth) {
                leftPanel.style.width = newLeftWidth + 'px';
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }
        });
    }

    // Global variables for auto-refresh
    window.autoRefreshInterval = null;
    const AUTO_REFRESH_RATE = 5000;

    document.addEventListener('DOMContentLoaded', function() {
        console.log("✅ Enhanced dashboard initializing...");
        
        const refreshBtn = document.getElementById('refresh-log-btn');
        const logBody = document.getElementById('job-log-body');
        
        console.log("🔍 Found refresh button:", !!refreshBtn);
        console.log("🔍 Found log body:", !!logBody);
        
        // Helper function to update button states based on current DOM  
        function updateButtonStates() {
            const allSelected = document.querySelectorAll('.selection-checkbox:checked, .job-selection-checkbox:checked');
            
            // Count video jobs for stitching
            const videoJobs = Array.from(allSelected).filter(cb => {
                const jobId = cb.dataset.jobId;
                if (jobId) {
                    // Find the job in the DOM to check if it's a video
                    const jobElement = cb.closest('.enhanced-job-item');
                    const hasVideo = jobElement && jobElement.querySelector('video');
                    return hasVideo;
                }
                return false;
            });
            
            // Count jobs that can be processed for keying 
            const keyingJobs = Array.from(allSelected).filter(cb => {
                const jobType = cb.dataset.jobType || '';
                return (jobType === 'animation' || jobType === 'video_stitching' || jobType === 'video_upload' || jobType === 'uploaded_video_keying');
            });
            
            const deleteSelectedBtn = document.getElementById('delete-selected-btn');
            const stitchBtn = document.getElementById('stitch-videos-btn');
            const processSelectedBtn = document.getElementById('process-selected-btn');
            
            if (deleteSelectedBtn) {
                deleteSelectedBtn.textContent = `🗑️ Delete Selected (${allSelected.length})`;
                deleteSelectedBtn.disabled = allSelected.length === 0;
            }
            
            if (stitchBtn) {
                stitchBtn.textContent = `🎬 Stitch Selected Videos (${videoJobs.length})`;
                stitchBtn.disabled = videoJobs.length !== 2;
            }
            
            if (processSelectedBtn) {
                processSelectedBtn.textContent = `⚙️ Process Selected Keys (${keyingJobs.length})`;
                processSelectedBtn.disabled = keyingJobs.length === 0;
                processSelectedBtn.style.display = keyingJobs.length > 0 ? 'inline-block' : 'none';
            }
        }

        // Main function to load and display jobs with enhanced rendering
        async function refreshJobLog() {
            if (!logBody) {
                console.error("❌ job-log-body element not found");
                return;
            }
            
            try {
                console.log("🔄 Fetching jobs...");
                const response = await fetch('/api/jobs');
                
                if (!response.ok) {
                    console.error(`HTTP Error: ${response.status} ${response.statusText}`);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    console.error('Response is not JSON:', contentType);
                    const text = await response.text();
                    console.error('Response text:', text.substring(0, 200));
                    throw new Error('Server returned non-JSON response');
                }
                
                const jobs = await response.json();
                console.log(`📊 Retrieved ${jobs.length} jobs`);
                
                if (jobs.length === 0) {
                    logBody.innerHTML = '<p>The job queue is empty.</p>';
                    return;
                }
                
                // Use enhanced rendering with grouping
                const html = renderGroupedJobs(jobs);
                logBody.innerHTML = html;
                console.log(`✅ Loaded ${jobs.length} jobs successfully`);
                
                // Reset button states after DOM refresh (fixes stale checkbox references)
                updateButtonStates();
                
                // After refresh, check if we should pause auto-refresh based on current state
                setTimeout(() => {
                    updateAutoRefreshBasedOnOpenJobs();
                }, 100);
                
            } catch (error) {
                console.error('❌ Error loading jobs:', error);
                logBody.innerHTML = `<p style="color: red;">Error loading jobs: ${error.message}</p>`;
            }
        }
        
        // Leonardo model name mapping
        const leonardoModelNames = {
            'b24e16ff-06e3-43eb-8d33-4416c2d75876': 'Leonardo Diffusion XL',
            '5c232a9e-9061-4777-980a-ddc8e65647c6': 'Leonardo Vision XL',
            '2067ae52-33fd-4a82-bb92-c2c55e7d2786': 'AlbedoBase XL',
            'replicate-gpt-image-1': 'OpenAI (via Replicate)',
            'bytedance-seedream-4': 'Bytedance Seedream-4',
            'kwaivgi/kling-v2.1': 'Kling v2.1',
            'bytedance/seedance-1-pro': 'Seedance-1 Pro',
            'pixverse/pixverse-v4.5': 'Pixverse v4.5'
        };
        
        function getModelDisplayName(modelId) {
            return leonardoModelNames[modelId] || modelId;
        }
        
        // Helper function to normalize file paths for consistent display
        function normalizeFilePath(filePath) {
            if (!filePath || typeof filePath !== 'string') return '';
            
            // Skip clearly invalid paths - return empty string to avoid broken URLs
            if (filePath.length > 200 || filePath.includes(' ') || !filePath.includes('.') || 
                filePath.startsWith('{') || filePath.includes('{') || filePath.includes('}') ||
                filePath.startsWith('This ') || filePath.startsWith('Error:')) {
                console.warn('Invalid file path detected and skipped:', filePath);
                return '';
            }
            
            // Remove any leading slashes and ensure consistent format
            let normalized = filePath.replace(/^\/+/, '');
            // If path doesn't start with 'static/', add it
            if (!normalized.startsWith('static/')) {
                normalized = `static/${normalized}`;
            }
            return normalized;
        }

        // Legacy function removed - now using enhanced rendering functions
        
        // Auto-refresh functionality
        function startAutoRefresh() {
            if (window.autoRefreshInterval) clearInterval(window.autoRefreshInterval);
            window.autoRefreshInterval = setInterval(window.refreshJobLog, AUTO_REFRESH_RATE);
            console.log('✅ Auto-refresh started, interval ID:', window.autoRefreshInterval);
            const currentRefreshBtn = window.refreshBtn || document.getElementById('refresh-log-btn');
            if (currentRefreshBtn) {
                currentRefreshBtn.textContent = '⏸️ Pause Auto-Refresh';
                currentRefreshBtn.classList.add('active');
                currentRefreshBtn.classList.remove('paused');
            }
        }
        
        function pauseAutoRefresh() {
            if (window.autoRefreshInterval) {
                clearInterval(window.autoRefreshInterval);
                window.autoRefreshInterval = null;
            }
            console.log('⏸️ Auto-refresh paused');
            const currentRefreshBtn = window.refreshBtn || document.getElementById('refresh-log-btn');
            if (currentRefreshBtn) {
                currentRefreshBtn.textContent = '▶️ Resume Auto-Refresh';
                currentRefreshBtn.classList.remove('active');
                currentRefreshBtn.classList.add('paused');
            }
        }
        
        // Refresh button functionality - Fixed version
        function setupRefreshButton() {
            console.log("Setting up refresh button, element found:", !!refreshBtn);
        if (refreshBtn) {
                refreshBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log("🔄 Refresh button clicked!");
                    console.log("🔄 Button has active class:", refreshBtn.classList.contains('active'));
                    console.log("🔄 Auto refresh interval exists:", !!window.autoRefreshInterval);
                    
                    if (window.autoRefreshInterval) {
                        console.log("🔄 Pausing auto-refresh");
                    pauseAutoRefresh();
                } else {
                        console.log("🔄 Starting auto-refresh");
                    startAutoRefresh();
                }
            });
                
                console.log("✅ Refresh button setup complete");
            } else {
                console.error("❌ Refresh button not found!");
            }
        }
        
        // Add all interactive event handlers
        function setupInteractiveHandlers() {
            // Delegate event listeners to the log body for dynamic content
            logBody.addEventListener('click', async function(event) {
                // Handle regenerate button
                const regenerateBtn = event.target.closest('.regenerate-btn');
                if (regenerateBtn) {
                    event.preventDefault();
                    regenerateBtn.textContent = 'Queuing...';
                    regenerateBtn.disabled = true;
                    const inputData = JSON.parse(regenerateBtn.dataset.input);
                    const formData = new FormData();
                    formData.append('object_prompt', inputData.object_prompt || '');
                    formData.append('style_prompt', inputData.style_prompt || '');
                    formData.append('modelId', inputData.modelId || '');
                    formData.append('presetStyle', inputData.presetStyle || 'NONE');
                    try {
                        const response = await fetch('/image-tool', { method: 'POST', body: formData });
                        if (!response.ok) throw new Error('Failed to queue regeneration job.');
                        await refreshJobLog();
                        document.getElementById('log-section')?.scrollIntoView({ behavior: 'smooth' });
                    } catch (error) {
                        showUserFriendlyError('Error regenerating: ' + error.message, error, 'error');
                        regenerateBtn.textContent = '🔄 Regenerate';
                        regenerateBtn.disabled = false;
                    }
                }

                // Handle delete button
                const deleteBtn = event.target.closest('.delete-item-btn');
                if (deleteBtn) {
                    event.preventDefault();
                    const jobId = deleteBtn.dataset.jobId;
                    if (confirm(`Are you sure you want to permanently delete job #${jobId}?`)) {
                        try {
                            const response = await fetch(`/api/batch-delete-items`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ job_ids: [jobId] })
                            });
                            if (!response.ok) {
                                const errorData = await response.json().catch(() => ({}));
                                throw new Error(errorData.error || `Server responded with status ${response.status}`);
                            }
                            await refreshJobLog();
                        } catch (error) {
                            console.error('Error deleting item:', error);
                            alert(`There was an error deleting the job: ${error.message}`);
                        }
                    }
                }

                // Handle use result button (for style/palette analysis)
                const useBtn = event.target.closest('.use-result-btn');
                if (useBtn) {
                    event.preventDefault();
                    const stylePromptTextarea = document.getElementById('style_prompt');
                    // Fix: Properly decode HTML entities instead of URL encoding
                    let resultText = useBtn.dataset.resultText
                        .replace(/&quot;/g, '"')
                        .replace(/&apos;/g, "'")
                        .replace(/&amp;/g, '&');
                    let styleToUse = resultText;
                    try {
                        const parsedResult = JSON.parse(resultText);
                        if (parsedResult.palette) {
                            styleToUse = parsedResult.palette.map(color => `${color.name} (${color.hex})`).join(', ') + ", vibrant color palette.";
                        }
                    } catch (e) { 
                        console.log('Using raw text for style analysis result:', resultText);
                        // Use raw text if not JSON 
                    }
                    
                    const existingStyle = stylePromptTextarea.value.trim();
                    stylePromptTextarea.value = existingStyle ? `${existingStyle}, ${styleToUse}` : styleToUse;
                    document.getElementById('image-parent-job-id').value = useBtn.dataset.jobId;
                    document.getElementById('generator-section').open = true;
                    stylePromptTextarea.focus();
                }

                // Handle extract frame button (for videos)
                const extractFrameBtn = event.target.closest('.extract-frame-btn');
                if (extractFrameBtn) {
                    event.preventDefault();
                    const videoSrc = extractFrameBtn.dataset.videoSrc;
                    const parentJobId = extractFrameBtn.dataset.jobId;
                    openExtractFrameModal(videoSrc, parentJobId);
                }

                // Handle re-stitch button
                const reStitchBtn = event.target.closest('.re-stitch-btn');
                if (reStitchBtn) {
                    event.preventDefault();
                    const jobId = reStitchBtn.dataset.jobId;
                    if (confirm('Re-stitch this video with the same source videos?')) {
                        try {
                            reStitchBtn.textContent = 'Re-stitching...';
                            reStitchBtn.disabled = true;
                            // Reset the job to queued status so it will be re-processed
                            fetch('/api/reset-job', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ job_id: jobId, new_status: 'queued' })
                            }).then(response => response.json()).then(data => {
                                if (data.success) {
                                    showUserFriendlyError('Job queued for re-stitching!', null, 'success');
                                    refreshJobLog();
                                } else {
                                    showUserFriendlyError('Error: ' + data.error, null, 'error');
                                }
                            });
                        } catch (error) {
                            showUserFriendlyError('Error: ' + error.message, error, 'error');
                            reStitchBtn.textContent = '🔄 Re-Stitch';
                            reStitchBtn.disabled = false;
                        }
                    }
                }

                // Handle retry stitch button (for failed jobs)
                const retryStitchBtn = event.target.closest('.retry-stitch-btn');
                if (retryStitchBtn) {
                    event.preventDefault();
                    const jobId = retryStitchBtn.dataset.jobId;
                    if (confirm('Retry stitching this failed job?')) {
                        try {
                            retryStitchBtn.textContent = 'Retrying...';
                            retryStitchBtn.disabled = true;
                            fetch('/api/reset-job', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ job_id: jobId, new_status: 'queued' })
                            }).then(response => response.json()).then(data => {
                                if (data.success) {
                                    showUserFriendlyError('Job queued for retry!', null, 'success');
                                    refreshJobLog();
                                } else {
                                    showUserFriendlyError('Error: ' + data.error, null, 'error');
                                }
                            });
                        } catch (error) {
                            showUserFriendlyError('Error: ' + error.message, error, 'error');
                            retryStitchBtn.textContent = '🔄 Retry Stitch';
                            retryStitchBtn.disabled = false;
                        }
                    }
                }

                // Handle retry key button (for failed keying jobs)
                const retryKeyBtn = event.target.closest('.retry-key-btn');
                if (retryKeyBtn) {
                    event.preventDefault();
                    const jobId = retryKeyBtn.dataset.jobId;
                    if (confirm('Retry keying this failed job?')) {
                        try {
                            retryKeyBtn.textContent = 'Retrying...';
                            retryKeyBtn.disabled = true;
                            fetch('/api/reset-job', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ job_id: jobId, new_status: 'pending_review' })
                            }).then(response => response.json()).then(data => {
                                if (data.success) {
                                    alert('Job reset for keying retry!');
                                    refreshJobLog();
                                } else {
                                    alert('Error: ' + data.error);
                                }
                            });
                        } catch (error) {
                            alert('Error: ' + error.message);
                            retryKeyBtn.textContent = '🔄 Retry Key';
                            retryKeyBtn.disabled = false;
                        }
                    }
                }

                // Handle view children button (for boomerang automation)
                const viewChildrenBtn = event.target.closest('.view-children-btn');
                if (viewChildrenBtn) {
                    event.preventDefault();
                    const jobId = viewChildrenBtn.dataset.jobId;
                    // Scroll to and highlight child jobs
                    const childElements = document.querySelectorAll(`[data-job-id]`);
                    let childCount = 0;
                    childElements.forEach(el => {
                        const jobEl = el.closest('.log-item-wrapper');
                        if (jobEl && jobEl.querySelector('.log-item-details')) {
                            // Check if this job mentions the parent ID (simple approach)
                            const detailsText = jobEl.querySelector('.log-item-details').textContent;
                            if (detailsText.includes(`Animation A->B:`) || detailsText.includes(`Animation B->A:`)) {
                                jobEl.style.border = '3px solid #20c997';
                                jobEl.style.backgroundColor = '#e7f9f5';
                                setTimeout(() => {
                                    jobEl.style.border = '';
                                    jobEl.style.backgroundColor = '';
                                }, 5000);
                                childCount++;
                            }
                        }
                    });
                    alert(`Highlighted ${childCount} child animation jobs for 5 seconds`);
                }

                // Handle cancel job button
                const cancelJobBtn = event.target.closest('.cancel-job-btn');
                if (cancelJobBtn) {
                    event.preventDefault();
                    const jobId = cancelJobBtn.dataset.jobId;
                    if (confirm(`Cancel job #${jobId}? This will mark it as failed and stop processing.`)) {
                        try {
                            cancelJobBtn.textContent = 'Cancelling...';
                            cancelJobBtn.disabled = true;
                            
                            const response = await fetch(`/api/cancel-job/${jobId}`, { method: 'POST' });
                            if (response.ok) {
                                const result = await response.json();
                                alert(result.message);
                                await refreshJobLog();
                            } else {
                                const error = await response.json();
                                alert('Error: ' + (error.error || 'Unknown error'));
                            }
                        } catch (error) {
                            alert('Network error: ' + error.message);
                        } finally {
                            cancelJobBtn.textContent = '❌ Cancel';
                            cancelJobBtn.disabled = false;
                        }
                    }
                }
            });

            // Handle checkbox selections for batch operations
            logBody.addEventListener('change', event => {
                if (event.target.classList.contains('selection-checkbox')) {
                    updateButtonStates();
                    
                    // Smart auto-refresh control based on selections and open jobs
                    updateAutoRefreshBasedOnOpenJobs();
                }
            });

            // Note: Auto-pause refresh logic moved to toggleJobDetails() and updateAutoRefreshBasedOnOpenJobs()

            // Handle form submissions within job log
            logBody.addEventListener('submit', async function(event) {
                if (event.target.classList.contains('button-form')) {
                    // This will be handled by the global form handler in base.html
                    return;
                }
            });
        }
        
        // Extract Frame Modal functionality
        const extractFrameModal = document.getElementById('extract-frame-modal');
        const modalVideoContainer = document.getElementById('modal-video-container');
        let currentVideo = null;
        let currentTime = 0;
        
        function openExtractFrameModal(videoSrc, parentJobId) {
            extractFrameModal.style.display = 'block';
            document.getElementById('modal-parent-job-id').value = parentJobId;
            
            modalVideoContainer.innerHTML = `
                <video id="modal-video" src="${videoSrc}" controls style="width: 100%; max-height: 400px;">
                    Your browser does not support the video tag.
                </video>
                <div class="frame-controls">
                    <input type="range" id="frame-scrubber" min="0" max="100" value="0" step="0.1" style="width: 100%; margin: 10px 0;">
                    <div class="time-display">
                        <span>Current Time: </span>
                        <span id="current-time-display">0.0s</span>
                        <span> / </span>
                        <span id="duration-display">-</span>
                    </div>
                </div>
            `;
            
            currentVideo = document.getElementById('modal-video');
            const frameScrubber = document.getElementById('frame-scrubber');
            const currentTimeDisplay = document.getElementById('current-time-display');
            const durationDisplay = document.getElementById('duration-display');
            
            // Update scrubber when video loads
            currentVideo.addEventListener('loadedmetadata', function() {
                frameScrubber.max = currentVideo.duration;
                durationDisplay.textContent = currentVideo.duration.toFixed(1) + 's';
            });
            
            // Update scrubber when video plays
            currentVideo.addEventListener('timeupdate', function() {
                frameScrubber.value = currentVideo.currentTime;
                currentTimeDisplay.textContent = currentVideo.currentTime.toFixed(1) + 's';
                currentTime = currentVideo.currentTime;
            });
            
            // Seek when scrubber is moved
            frameScrubber.addEventListener('input', function() {
                currentVideo.currentTime = frameScrubber.value;
                currentTime = frameScrubber.value;
                currentTimeDisplay.textContent = frameScrubber.value + 's';
            });
        }
        
        // Frame navigation buttons
        document.getElementById('modal-prev-frame-btn').addEventListener('click', function() {
            if (currentVideo) {
                const frameRate = 30; // Assume 30fps
                currentVideo.currentTime = Math.max(0, currentVideo.currentTime - (1/frameRate));
            }
        });
        
        document.getElementById('modal-next-frame-btn').addEventListener('click', function() {
            if (currentVideo) {
                const frameRate = 30; // Assume 30fps
                currentVideo.currentTime = Math.min(currentVideo.duration, currentVideo.currentTime + (1/frameRate));
            }
        });
        
        // Save frame button - Updated to stay open
        document.getElementById('modal-save-frame-btn').addEventListener('click', async function() {
            if (!currentVideo) {
                alert('No video loaded');
                return;
            }
            
            const parentJobId = document.getElementById('modal-parent-job-id').value;
            // Extract the proper relative path from the video source
            const videoFullSrc = currentVideo.src;
            const baseUrl = window.location.origin;
            let videoSrc = videoFullSrc;
            
            // Remove base URL if present to get relative path
            if (videoFullSrc.startsWith(baseUrl)) {
                videoSrc = videoFullSrc.substring(baseUrl.length);
            }
            
            // Remove leading slash if present
            if (videoSrc.startsWith('/')) {
                videoSrc = videoSrc.substring(1);
            }
            
            console.log('Extracting frame from video path:', videoSrc);
            
            try {
                this.textContent = 'Extracting...';
                this.disabled = true;
                
                const response = await fetch('/api/extract-frame', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        video_path: videoSrc,
                        frame_time: currentTime,
                        parent_job_id: parentJobId
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Show success message but keep modal open
                    showUserFriendlyError('Frame extracted successfully!', null, 'success');
                    // Don't close the modal - let user extract more frames
                    await refreshJobLog();
                } else {
                    const error = await response.json();
                    showUserFriendlyError('Error extracting frame: ' + (error.error || 'Unknown error'), null, 'error');
                }
            } catch (error) {
                showUserFriendlyError('Network error: ' + error.message, error, 'error');
            } finally {
                this.textContent = 'Save This Frame';
                this.disabled = false;
            }
        });
        
        // Modal close functionality
        document.querySelector('#extract-frame-modal .close-button').addEventListener('click', function() {
            extractFrameModal.style.display = 'none';
        });
        
        window.addEventListener('click', function(event) {
            if (event.target === extractFrameModal) {
                extractFrameModal.style.display = 'none';
            }
        });
        
        // Batch delete functionality
        const deleteSelectedBtn = document.getElementById('delete-selected-btn');
        if (deleteSelectedBtn) {
            deleteSelectedBtn.addEventListener('click', async function() {
                const selectedCheckboxes = document.querySelectorAll('.selection-checkbox:checked');
                const jobIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.jobId);
                
                if (jobIds.length === 0) {
                    alert('No jobs selected for deletion.');
                    return;
                }
                
                if (confirm(`Are you sure you want to permanently delete ${jobIds.length} selected jobs?`)) {
                    try {
                        this.textContent = 'Deleting...';
                        this.disabled = true;
                        
                        const response = await fetch('/api/batch-delete-items', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ job_ids: jobIds })
                        });
                        
                        if (response.ok) {
                            alert(`${jobIds.length} jobs deleted successfully!`);
                            await refreshJobLog();
                        } else {
                            const error = await response.json();
                            alert('Error deleting jobs: ' + (error.error || 'Unknown error'));
                        }
                    } catch (error) {
                        alert('Network error: ' + error.message);
                    } finally {
                        this.textContent = '🗑️ Delete Selected (0)';
                        this.disabled = false;
                        this.style.display = 'none';
                    }
                }
            });
        }
        
        // Video stitching functionality
        const stitchBtn = document.getElementById('stitch-videos-btn');
        if (stitchBtn) {
            stitchBtn.addEventListener('click', async function() {
                const selectedVideos = document.querySelectorAll('.video-stitch-checkbox:checked');
                const videoPaths = Array.from(selectedVideos).map(cb => cb.dataset.videoPath);
                
                if (videoPaths.length !== 2) {
                    alert('Please select exactly 2 videos to stitch together.');
                    return;
                }
                
                if (confirm('Stitch the selected videos together?')) {
                    try {
                        this.textContent = 'Stitching...';
                        this.disabled = true;
                        
                        const response = await fetch('/stitch-videos', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ video_paths: videoPaths })
                        });
                        
                        if (response.ok) {
                            alert('Videos stitched successfully!');
                            await refreshJobLog();
                        } else {
                            const error = await response.json();
                            alert('Error stitching videos: ' + (error.error || 'Unknown error'));
                        }
                    } catch (error) {
                        alert('Network error: ' + error.message);
                    } finally {
                        this.textContent = '🎬 Stitch Selected Videos (0)';
                        this.disabled = true;
                    }
                }
            });
        }
        
        // Process all pending keys button (jobs with saved settings)
        const processPendingBtn = document.getElementById('process-pending-btn');
        if (processPendingBtn) {
            processPendingBtn.addEventListener('click', async function() {
                if (confirm('Process all pending jobs that have keying settings saved?')) {
                    try {
                        this.textContent = 'Processing...';
                        this.disabled = true;
                        
                        const response = await fetch('/process-all-pending', { method: 'POST' });
                        
                        if (response.ok) {
                            const result = await response.json();
                            alert(result.message || 'All pending jobs have been queued for keying!');
                            // Refresh job log to show updated status
                            console.log('🔄 Refreshing job log for keying jobs');
                            await refreshJobLog();
                        } else {
                            const error = await response.json();
                            alert('Error: ' + (error.error || 'Unknown error processing pending jobs.'));
                        }
                    } catch (error) {
                        alert('Network error: ' + error.message);
                    } finally {
                        this.textContent = '⚙️ Process Pending Keys';
                        this.disabled = false;
                    }
                }
            });
        }
        
        // Process selected animations button
        const processSelectedBtn = document.getElementById('process-selected-btn');
        if (processSelectedBtn) {
            processSelectedBtn.addEventListener('click', async function() {
                const selectedCheckboxes = document.querySelectorAll('.selection-checkbox:checked');
                const pendingKeyingJobs = Array.from(selectedCheckboxes).filter(cb => {
                    const jobType = cb.dataset.jobType || '';
                    return (jobType === 'animation' || jobType === 'video_stitching' || jobType === 'video_upload' || jobType === 'uploaded_video_keying');
                });
                
                const jobIds = pendingKeyingJobs.map(cb => cb.dataset.jobId);
                
                if (jobIds.length === 0) {
                    showUserFriendlyError('No video jobs selected for keying.', null, 'error');
                    return;
                }
                
                try {
                    this.textContent = 'Processing...';
                    this.disabled = true;
                    
                    const response = await fetch('/process-selected-pending', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ job_ids: jobIds })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        showUserFriendlyError(result.message || 'Selected jobs have been queued for keying!', null, 'success');
                        await refreshJobLog();
                    } else {
                        const error = await response.json();
                        showUserFriendlyError('Error: ' + (error.error || 'Unknown error processing selected jobs.'), null, 'error');
                    }
                } catch (error) {
                    showUserFriendlyError('Network error: ' + error.message, error, 'error');
                } finally {
                    this.textContent = '⚙️ Process Selected Keys (0)';
                    this.disabled = false;
                    this.style.display = 'none';
                }
            });
        }
        
        // Clear failed jobs button
        const clearFailedBtn = document.getElementById('clear-failed-btn');
        if (clearFailedBtn) {
            clearFailedBtn.addEventListener('click', async function() {
                if (confirm('Clear all failed jobs from the database? This action cannot be undone.')) {
                    try {
                        this.textContent = 'Clearing...';
                        this.disabled = true;
                        
                        const response = await fetch('/api/clear-failed-jobs', { method: 'POST' });
                        if (response.ok) {
                            const result = await response.json();
                            alert(result.message);
                            await refreshJobLog();
                        } else {
                            const error = await response.json();
                            alert('Error: ' + (error.error || 'Unknown error'));
                        }
                    } catch (error) {
                        alert('Network error: ' + error.message);
                    } finally {
                        this.textContent = '🧹 Clear Failed';
                        this.disabled = false;
                    }
                }
            });
        }
        
        // Clear stuck jobs button
        const clearStuckBtn = document.getElementById('clear-stuck-btn');
        if (clearStuckBtn) {
            clearStuckBtn.addEventListener('click', async function() {
                if (confirm('Clear all stuck processing jobs? This will cancel jobs that are taking too long (processing, stitching, keying). This action cannot be undone.')) {
                    try {
                        this.textContent = 'Clearing...';
                        this.disabled = true;
                        
                        const response = await fetch('/api/clear-stuck-jobs', { method: 'POST' });
                        if (response.ok) {
                            const result = await response.json();
                            alert(result.message);
                            await refreshJobLog();
                        } else {
                            const error = await response.json();
                            alert('Error: ' + (error.error || 'Unknown error'));
                        }
                    } catch (error) {
                        alert('Network error: ' + error.message);
                    } finally {
                        this.textContent = '⚠️ Clear Stuck';
                        this.disabled = false;
                    }
                }
            });
        }
        
        // Clear all jobs button
        const clearAllBtn = document.getElementById('clear-all-btn');
        if (clearAllBtn) {
            clearAllBtn.addEventListener('click', async function() {
                if (confirm('⚠️ DANGER: Clear ALL jobs from the database? This will delete EVERYTHING and cannot be undone!')) {
                    if (confirm('Are you absolutely sure? This will permanently delete all jobs, completed work, and job history.')) {
                        try {
                            this.textContent = 'Clearing...';
                            this.disabled = true;
                            
                            const response = await fetch('/api/clear-all-jobs', { method: 'POST' });
                            if (response.ok) {
                                const result = await response.json();
                                showUserFriendlyError(result.message, null, 'success');
                                await refreshJobLog();
                            } else {
                                const error = await response.json();
                                showUserFriendlyError('Error: ' + (error.error || 'Unknown error'), null, 'error');
                            }
                        } catch (error) {
                            showUserFriendlyError('Network error: ' + error.message, error, 'error');
                        } finally {
                            this.textContent = '🗑️ Clear All Jobs';
                            this.disabled = false;
                        }
                    }
                }
            });
        }

        // Style analyzer prompt unlock functionality
        const unlockStylePromptCheckbox = document.getElementById('unlock_style_prompt');
        const stylePromptTextarea = document.getElementById('style_system_prompt');
        
        if (unlockStylePromptCheckbox && stylePromptTextarea) {
            unlockStylePromptCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    stylePromptTextarea.disabled = false;
                    stylePromptTextarea.style.backgroundColor = '#fff';
                    stylePromptTextarea.style.cursor = 'text';
                    console.log('✅ Style prompt textarea unlocked for editing');
                } else {
                    stylePromptTextarea.disabled = true;
                    stylePromptTextarea.style.backgroundColor = '#e9ecef';
                    stylePromptTextarea.style.cursor = 'not-allowed';
                    console.log('🔒 Style prompt textarea locked');
                }
            });
        }

        // Palette analyzer prompt unlock functionality
        const unlockPalettePromptCheckbox = document.getElementById('unlock_palette_prompt');
        const palettePromptTextarea = document.getElementById('palette_system_prompt');
        
        if (unlockPalettePromptCheckbox && palettePromptTextarea) {
            unlockPalettePromptCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    palettePromptTextarea.disabled = false;
                    palettePromptTextarea.style.backgroundColor = '#fff';
                    palettePromptTextarea.style.cursor = 'text';
                    console.log('✅ Palette prompt textarea unlocked for editing');
                } else {
                    palettePromptTextarea.disabled = true;
                    palettePromptTextarea.style.backgroundColor = '#e9ecef';
                    palettePromptTextarea.style.cursor = 'not-allowed';
                    console.log('🔒 Palette prompt textarea locked');
                }
            });
        }

        // Initialize resizable divider
        initResizable();
        
        // Enhanced event listeners for new UI
        document.addEventListener('change', function(event) {
            if (event.target.classList.contains('selection-checkbox') || 
                event.target.classList.contains('job-selection-checkbox') ||
                event.target.classList.contains('image-checkbox')) {
                
                console.log('🔄 Checkbox change detected');
                updateButtonStates();
                
                // Auto-pause refresh when user selects items
                const anySelected = document.querySelectorAll('.selection-checkbox:checked, .job-selection-checkbox:checked, .image-checkbox:checked');
                console.log('📊 Selected items:', anySelected.length);
                console.log('📊 Auto-refresh interval exists:', !!window.autoRefreshInterval);
                
                if (anySelected.length > 0 && window.autoRefreshInterval) {
                    console.log('🔄 Auto-pausing refresh due to selection');
                    window.pauseAutoRefresh();
                } else if (anySelected.length === 0 && !window.autoRefreshInterval) {
                    console.log('🔄 Auto-resuming refresh - no selections');
                    window.startAutoRefresh();
                }
            }
        });
        
        // Make functions globally available
        window.updateButtonStates = updateButtonStates;
        window.refreshJobLog = refreshJobLog;
        window.startAutoRefresh = startAutoRefresh;
        window.pauseAutoRefresh = pauseAutoRefresh;

        // Initialize
        console.log("🚀 Enhanced dashboard starting...");
        setupRefreshButton();
        setupInteractiveHandlers();
        refreshJobLog();
        startAutoRefresh();
    });
</script>
{% endblock %}